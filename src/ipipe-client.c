/* ipipe-client.c generated by valac 0.11.5, the Vala compiler
 * generated from ipipe-client.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <readline/history.h>
#include <readline/readline.h>


#define TYPE_ICLI_IPIPE (icli_ipipe_get_type ())
#define ICLI_IPIPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ICLI_IPIPE, ICliIpipe))
#define IS_ICLI_IPIPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ICLI_IPIPE))
#define ICLI_IPIPE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_ICLI_IPIPE, ICliIpipeIface))

typedef struct _ICliIpipe ICliIpipe;
typedef struct _ICliIpipeIface ICliIpipeIface;

#define TYPE_ICLI_IPIPE_PROXY (icli_ipipe_proxy_get_type ())
typedef GDBusProxy ICliIpipeProxy;
typedef GDBusProxyClass ICliIpipeProxyClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_IPIPE_CLI (ipipe_cli_get_type ())
#define IPIPE_CLI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IPIPE_CLI, IpipeCli))
#define IPIPE_CLI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IPIPE_CLI, IpipeCliClass))
#define IS_IPIPE_CLI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IPIPE_CLI))
#define IS_IPIPE_CLI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IPIPE_CLI))
#define IPIPE_CLI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IPIPE_CLI, IpipeCliClass))

typedef struct _IpipeCli IpipeCli;
typedef struct _IpipeCliClass IpipeCliClass;
typedef struct _IpipeCliPrivate IpipeCliPrivate;

#define TYPE_COMMAND_MANAGER (command_manager_get_type ())
#define COMMAND_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMMAND_MANAGER, CommandManager))
#define COMMAND_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMMAND_MANAGER, CommandManagerClass))
#define IS_COMMAND_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMMAND_MANAGER))
#define IS_COMMAND_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMMAND_MANAGER))
#define COMMAND_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMMAND_MANAGER, CommandManagerClass))

typedef struct _CommandManager CommandManager;
typedef struct _CommandManagerClass CommandManagerClass;

#define TYPE_ABSTC_CLI_REGISTER (abstc_cli_register_get_type ())
#define ABSTC_CLI_REGISTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ABSTC_CLI_REGISTER, AbstcCliRegister))
#define ABSTC_CLI_REGISTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ABSTC_CLI_REGISTER, AbstcCliRegisterClass))
#define IS_ABSTC_CLI_REGISTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ABSTC_CLI_REGISTER))
#define IS_ABSTC_CLI_REGISTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ABSTC_CLI_REGISTER))
#define ABSTC_CLI_REGISTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ABSTC_CLI_REGISTER, AbstcCliRegisterClass))

typedef struct _AbstcCliRegister AbstcCliRegister;
typedef struct _AbstcCliRegisterClass AbstcCliRegisterClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))

#define TYPE_CLI_DM365IPIPE (cli_dm365ipipe_get_type ())
#define CLI_DM365IPIPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLI_DM365IPIPE, cli_dm365ipipe))
#define CLI_DM365IPIPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CLI_DM365IPIPE, cli_dm365ipipeClass))
#define IS_CLI_DM365IPIPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLI_DM365IPIPE))
#define IS_CLI_DM365IPIPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CLI_DM365IPIPE))
#define CLI_DM365IPIPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CLI_DM365IPIPE, cli_dm365ipipeClass))

typedef struct _cli_dm365ipipe cli_dm365ipipe;
typedef struct _cli_dm365ipipeClass cli_dm365ipipeClass;

#define TYPE_CLI_MT9P031 (cli_mt9p031_get_type ())
#define CLI_MT9P031(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLI_MT9P031, cli_mt9p031))
#define CLI_MT9P031_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CLI_MT9P031, cli_mt9p031Class))
#define IS_CLI_MT9P031(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLI_MT9P031))
#define IS_CLI_MT9P031_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CLI_MT9P031))
#define CLI_MT9P031_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CLI_MT9P031, cli_mt9p031Class))

typedef struct _cli_mt9p031 cli_mt9p031;
typedef struct _cli_mt9p031Class cli_mt9p031Class;

struct _ICliIpipeIface {
	GTypeInterface parent_iface;
	void (*enable_debug) (ICliIpipe* self, gboolean enable, GError** error);
	gboolean (*ping) (ICliIpipe* self, GError** error);
	gchar* (*get_video_processor) (ICliIpipe* self, GError** error);
	gchar* (*get_sensor) (ICliIpipe* self, GError** error);
	gint (*init_aew) (ICliIpipe* self, const gchar* wb, const gchar* ae, const gchar* g, const gchar* meter, gint time, gint fps, gint segment_factor, gint width, gint height, GError** error);
	void (*close_aew) (ICliIpipe* self, GError** error);
};

struct _IpipeCli {
	GObject parent_instance;
	IpipeCliPrivate * priv;
	CommandManager* cmd;
};

struct _IpipeCliClass {
	GObjectClass parent_class;
};

struct _IpipeCliPrivate {
	gboolean cli_enable;
	ICliIpipe* ipipe;
	AbstcCliRegister* video_processor_i;
	AbstcCliRegister* sensor_i;
};

typedef gint (*IpipeCommandCmdFunc) (gchar** s, int s_length1, void* user_data);

static gpointer ipipe_cli_parent_class = NULL;
static gchar* ipipe_cli__cmd_name;
static gchar* ipipe_cli__cmd_name = NULL;
static gboolean ipipe_cli__debug;
static gboolean ipipe_cli__debug = FALSE;
static gchar** ipipe_cli__remaining_args;
static gchar** ipipe_cli__remaining_args = NULL;

GType icli_ipipe_proxy_get_type (void) G_GNUC_CONST;
guint icli_ipipe_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType icli_ipipe_get_type (void) G_GNUC_CONST;
void icli_ipipe_enable_debug (ICliIpipe* self, gboolean enable, GError** error);
gboolean icli_ipipe_ping (ICliIpipe* self, GError** error);
gchar* icli_ipipe_get_video_processor (ICliIpipe* self, GError** error);
gchar* icli_ipipe_get_sensor (ICliIpipe* self, GError** error);
gint icli_ipipe_init_aew (ICliIpipe* self, const gchar* wb, const gchar* ae, const gchar* g, const gchar* meter, gint time, gint fps, gint segment_factor, gint width, gint height, GError** error);
void icli_ipipe_close_aew (ICliIpipe* self, GError** error);
static void icli_ipipe_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
static void icli_ipipe_proxy_enable_debug (ICliIpipe* self, gboolean enable, GError** error);
static gboolean icli_ipipe_proxy_ping (ICliIpipe* self, GError** error);
static gchar* icli_ipipe_proxy_get_video_processor (ICliIpipe* self, GError** error);
static gchar* icli_ipipe_proxy_get_sensor (ICliIpipe* self, GError** error);
static gint icli_ipipe_proxy_init_aew (ICliIpipe* self, const gchar* wb, const gchar* ae, const gchar* g, const gchar* meter, gint time, gint fps, gint segment_factor, gint width, gint height, GError** error);
static void icli_ipipe_proxy_close_aew (ICliIpipe* self, GError** error);
static void icli_ipipe_proxy_icli_ipipe_interface_init (ICliIpipeIface* iface);
static void _dbus_icli_ipipe_enable_debug (ICliIpipe* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_icli_ipipe_ping (ICliIpipe* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_icli_ipipe_get_video_processor (ICliIpipe* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_icli_ipipe_get_sensor (ICliIpipe* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_icli_ipipe_init_aew (ICliIpipe* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_icli_ipipe_close_aew (ICliIpipe* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void icli_ipipe_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* icli_ipipe_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean icli_ipipe_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _icli_ipipe_unregister_object (gpointer user_data);
GType ipipe_cli_get_type (void) G_GNUC_CONST;
GType command_manager_get_type (void) G_GNUC_CONST;
GType abstc_cli_register_get_type (void) G_GNUC_CONST;
#define IPIPE_CLI_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_IPIPE_CLI, IpipeCliPrivate))
enum  {
	IPIPE_CLI_DUMMY_PROPERTY
};
CommandManager* command_manager_new (void);
CommandManager* command_manager_construct (GType object_type);
IpipeCli* ipipe_cli_new (GError** error);
IpipeCli* ipipe_cli_construct (GType object_type, GError** error);
void ipipe_cli_Error_cb (IpipeCli* self);
static gint ipipe_cli_cli_enable_debug (IpipeCli* self, gchar** args, int args_length1);
static gint ipipe_cli_cli_ping (IpipeCli* self, gchar** args, int args_length1);
static gint ipipe_cli_cli_shell (IpipeCli* self, gchar** args, int args_length1);
static gint ipipe_cli_cli_get_video_processor (IpipeCli* self, gchar** args, int args_length1);
static gint ipipe_cli_cli_get_sensor (IpipeCli* self, gchar** args, int args_length1);
static gint ipipe_cli_cli_run_config_script (IpipeCli* self, gchar** args, int args_length1);
gint command_manager_execute_cmd (CommandManager* self, gchar** args, int args_length1);
static gint ipipe_cli_cli_ini_aew (IpipeCli* self, gchar** args, int args_length1);
static gint ipipe_cli_cli_stop_aew (IpipeCli* self, gchar** args, int args_length1);
static gint ipipe_cli_cli_exit (IpipeCli* self, gchar** args, int args_length1);
static void ipipe_cli_initialize_cmd_array (IpipeCli* self);
void command_manager_new_command (CommandManager* self, const gchar* _name, IpipeCommandCmdFunc _cmdfunc, void* _cmdfunc_target, const gchar* _usage, const gchar* _doc, const gchar* _args);
gint command_manager_command_help (CommandManager* self, gchar** args, int args_length1);
static gint _command_manager_command_help_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self);
static gint _ipipe_cli_cli_enable_debug_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self);
static gint _ipipe_cli_cli_ini_aew_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self);
static gint _ipipe_cli_cli_stop_aew_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self);
static gint _ipipe_cli_cli_shell_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self);
static gint _ipipe_cli_cli_ping_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self);
static gint _ipipe_cli_cli_exit_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self);
static gint _ipipe_cli_cli_get_video_processor_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self);
static gint _ipipe_cli_cli_get_sensor_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self);
static gint _ipipe_cli_cli_run_config_script_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self);
gboolean ipipe_cli_parse_options (IpipeCli* self, gchar** args, int args_length1);
gboolean ipipe_cli_parse_cmd (IpipeCli* self, gchar** rem_args, int rem_args_length1, GError** error);
gboolean ipipe_cli_parse_config (IpipeCli* self, IpipeCli* cli, GError** error);
cli_dm365ipipe* cli_dm365ipipe_new (gboolean debug, GError** error);
cli_dm365ipipe* cli_dm365ipipe_construct (GType object_type, gboolean debug, GError** error);
GType cli_dm365ipipe_get_type (void) G_GNUC_CONST;
void abstc_cli_register_registration (AbstcCliRegister* self, IpipeCli* cli, GError** error);
cli_mt9p031* cli_mt9p031_new (gboolean debug);
cli_mt9p031* cli_mt9p031_construct (GType object_type, gboolean debug);
GType cli_mt9p031_get_type (void) G_GNUC_CONST;
static gint ipipe_cli_main (gchar** args, int args_length1);
static void ipipe_cli_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const GDBusArgInfo _icli_ipipe_dbus_arg_info_enable_debug_enable = {-1, "enable", "b"};
static const GDBusArgInfo * const _icli_ipipe_dbus_arg_info_enable_debug_in[] = {&_icli_ipipe_dbus_arg_info_enable_debug_enable, NULL};
static const GDBusArgInfo * const _icli_ipipe_dbus_arg_info_enable_debug_out[] = {NULL};
static const GDBusMethodInfo _icli_ipipe_dbus_method_info_enable_debug = {-1, "EnableDebug", (GDBusArgInfo **) (&_icli_ipipe_dbus_arg_info_enable_debug_in), (GDBusArgInfo **) (&_icli_ipipe_dbus_arg_info_enable_debug_out)};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_ping_result = {-1, "result", "b"};
static const GDBusArgInfo * const _icli_ipipe_dbus_arg_info_ping_in[] = {NULL};
static const GDBusArgInfo * const _icli_ipipe_dbus_arg_info_ping_out[] = {&_icli_ipipe_dbus_arg_info_ping_result, NULL};
static const GDBusMethodInfo _icli_ipipe_dbus_method_info_ping = {-1, "Ping", (GDBusArgInfo **) (&_icli_ipipe_dbus_arg_info_ping_in), (GDBusArgInfo **) (&_icli_ipipe_dbus_arg_info_ping_out)};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_get_video_processor_result = {-1, "result", "s"};
static const GDBusArgInfo * const _icli_ipipe_dbus_arg_info_get_video_processor_in[] = {NULL};
static const GDBusArgInfo * const _icli_ipipe_dbus_arg_info_get_video_processor_out[] = {&_icli_ipipe_dbus_arg_info_get_video_processor_result, NULL};
static const GDBusMethodInfo _icli_ipipe_dbus_method_info_get_video_processor = {-1, "GetVideoProcessor", (GDBusArgInfo **) (&_icli_ipipe_dbus_arg_info_get_video_processor_in), (GDBusArgInfo **) (&_icli_ipipe_dbus_arg_info_get_video_processor_out)};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_get_sensor_result = {-1, "result", "s"};
static const GDBusArgInfo * const _icli_ipipe_dbus_arg_info_get_sensor_in[] = {NULL};
static const GDBusArgInfo * const _icli_ipipe_dbus_arg_info_get_sensor_out[] = {&_icli_ipipe_dbus_arg_info_get_sensor_result, NULL};
static const GDBusMethodInfo _icli_ipipe_dbus_method_info_get_sensor = {-1, "GetSensor", (GDBusArgInfo **) (&_icli_ipipe_dbus_arg_info_get_sensor_in), (GDBusArgInfo **) (&_icli_ipipe_dbus_arg_info_get_sensor_out)};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_init_aew_wb = {-1, "wb", "s"};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_init_aew_ae = {-1, "ae", "s"};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_init_aew_g = {-1, "g", "s"};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_init_aew_meter = {-1, "meter", "s"};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_init_aew_time = {-1, "time", "i"};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_init_aew_fps = {-1, "fps", "i"};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_init_aew_segment_factor = {-1, "segment_factor", "i"};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_init_aew_width = {-1, "width", "i"};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_init_aew_height = {-1, "height", "i"};
static const GDBusArgInfo _icli_ipipe_dbus_arg_info_init_aew_result = {-1, "result", "i"};
static const GDBusArgInfo * const _icli_ipipe_dbus_arg_info_init_aew_in[] = {&_icli_ipipe_dbus_arg_info_init_aew_wb, &_icli_ipipe_dbus_arg_info_init_aew_ae, &_icli_ipipe_dbus_arg_info_init_aew_g, &_icli_ipipe_dbus_arg_info_init_aew_meter, &_icli_ipipe_dbus_arg_info_init_aew_time, &_icli_ipipe_dbus_arg_info_init_aew_fps, &_icli_ipipe_dbus_arg_info_init_aew_segment_factor, &_icli_ipipe_dbus_arg_info_init_aew_width, &_icli_ipipe_dbus_arg_info_init_aew_height, NULL};
static const GDBusArgInfo * const _icli_ipipe_dbus_arg_info_init_aew_out[] = {&_icli_ipipe_dbus_arg_info_init_aew_result, NULL};
static const GDBusMethodInfo _icli_ipipe_dbus_method_info_init_aew = {-1, "InitAew", (GDBusArgInfo **) (&_icli_ipipe_dbus_arg_info_init_aew_in), (GDBusArgInfo **) (&_icli_ipipe_dbus_arg_info_init_aew_out)};
static const GDBusArgInfo * const _icli_ipipe_dbus_arg_info_close_aew_in[] = {NULL};
static const GDBusArgInfo * const _icli_ipipe_dbus_arg_info_close_aew_out[] = {NULL};
static const GDBusMethodInfo _icli_ipipe_dbus_method_info_close_aew = {-1, "CloseAew", (GDBusArgInfo **) (&_icli_ipipe_dbus_arg_info_close_aew_in), (GDBusArgInfo **) (&_icli_ipipe_dbus_arg_info_close_aew_out)};
static const GDBusMethodInfo * const _icli_ipipe_dbus_method_info[] = {&_icli_ipipe_dbus_method_info_enable_debug, &_icli_ipipe_dbus_method_info_ping, &_icli_ipipe_dbus_method_info_get_video_processor, &_icli_ipipe_dbus_method_info_get_sensor, &_icli_ipipe_dbus_method_info_init_aew, &_icli_ipipe_dbus_method_info_close_aew, NULL};
static const GDBusSignalInfo * const _icli_ipipe_dbus_signal_info[] = {NULL};
static const GDBusPropertyInfo * const _icli_ipipe_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _icli_ipipe_dbus_interface_info = {-1, "com.ridgerun.ipiped.IpipeInterface", (GDBusMethodInfo **) (&_icli_ipipe_dbus_method_info), (GDBusSignalInfo **) (&_icli_ipipe_dbus_signal_info), (GDBusPropertyInfo **) (&_icli_ipipe_dbus_property_info)};
static const GDBusInterfaceVTable _icli_ipipe_dbus_interface_vtable = {icli_ipipe_dbus_interface_method_call, icli_ipipe_dbus_interface_get_property, icli_ipipe_dbus_interface_set_property};
static const GOptionEntry IPIPE_CLI_options[4] = {{"command-help", 'h', 0, G_OPTION_ARG_STRING, &ipipe_cli__cmd_name, "Display possible commands for this application.\n\t\t\t " "\n\t\t\t Usage:-h <cmd_name>", NULL}, {"debug", 'd', 0, G_OPTION_ARG_INT, &ipipe_cli__debug, "Flag to enable debug information on ipipe-client." "\n\t\t\t Usage:-d <1>", NULL}, {"", '\0', 0, G_OPTION_ARG_FILENAME_ARRAY, &ipipe_cli__remaining_args, NULL, "[COMMANDS...]"}, {NULL}};

void icli_ipipe_enable_debug (ICliIpipe* self, gboolean enable, GError** error) {
	ICLI_IPIPE_GET_INTERFACE (self)->enable_debug (self, enable, error);
}


gboolean icli_ipipe_ping (ICliIpipe* self, GError** error) {
	return ICLI_IPIPE_GET_INTERFACE (self)->ping (self, error);
}


gchar* icli_ipipe_get_video_processor (ICliIpipe* self, GError** error) {
	return ICLI_IPIPE_GET_INTERFACE (self)->get_video_processor (self, error);
}


gchar* icli_ipipe_get_sensor (ICliIpipe* self, GError** error) {
	return ICLI_IPIPE_GET_INTERFACE (self)->get_sensor (self, error);
}


gint icli_ipipe_init_aew (ICliIpipe* self, const gchar* wb, const gchar* ae, const gchar* g, const gchar* meter, gint time, gint fps, gint segment_factor, gint width, gint height, GError** error) {
	return ICLI_IPIPE_GET_INTERFACE (self)->init_aew (self, wb, ae, g, meter, time, fps, segment_factor, width, height, error);
}


void icli_ipipe_close_aew (ICliIpipe* self, GError** error) {
	ICLI_IPIPE_GET_INTERFACE (self)->close_aew (self, error);
}


static void icli_ipipe_base_init (ICliIpipeIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


/**
 * ipiped/src/ipipe-client.vala
 *
 * Command line utility for sending D-Bus messages to Ipipe daemon with interactive support.
 *
 * Copyright (c) 2010, RidgeRun
 * All rights reserved.
 *
 * GPL2 license - See http://www.opensource.org/licenses/gpl-2.0.php for complete text.
*/
GType icli_ipipe_get_type (void) {
	static volatile gsize icli_ipipe_type_id__volatile = 0;
	if (g_once_init_enter (&icli_ipipe_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ICliIpipeIface), (GBaseInitFunc) icli_ipipe_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType icli_ipipe_type_id;
		icli_ipipe_type_id = g_type_register_static (G_TYPE_INTERFACE, "ICliIpipe", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (icli_ipipe_type_id, G_TYPE_OBJECT);
		g_type_set_qdata (icli_ipipe_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) icli_ipipe_proxy_get_type);
		g_type_set_qdata (icli_ipipe_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "com.ridgerun.ipiped.IpipeInterface");
		g_type_set_qdata (icli_ipipe_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) icli_ipipe_register_object);
		g_once_init_leave (&icli_ipipe_type_id__volatile, icli_ipipe_type_id);
	}
	return icli_ipipe_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (ICliIpipeProxy, icli_ipipe_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_ICLI_IPIPE, icli_ipipe_proxy_icli_ipipe_interface_init) );
static void icli_ipipe_proxy_class_init (ICliIpipeProxyClass* klass) {
	G_DBUS_PROXY_CLASS (klass)->g_signal = icli_ipipe_proxy_g_signal;
}


static void icli_ipipe_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
}


static void icli_ipipe_proxy_init (ICliIpipeProxy* self) {
}


static void icli_ipipe_proxy_enable_debug (ICliIpipe* self, gboolean enable, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "com.ridgerun.ipiped.IpipeInterface", "EnableDebug");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_boolean (enable));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static gboolean icli_ipipe_proxy_ping (ICliIpipe* self, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	GVariant *_reply;
	GVariantIter _reply_iter;
	gboolean _result;
	GVariant* _tmp0_;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "com.ridgerun.ipiped.IpipeInterface", "Ping");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return FALSE;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return FALSE;
	}
	_reply = g_dbus_message_get_body (_reply_message);
	g_variant_iter_init (&_reply_iter, _reply);
	_tmp0_ = g_variant_iter_next_value (&_reply_iter);
	_result = g_variant_get_boolean (_tmp0_);
	g_variant_unref (_tmp0_);
	g_object_unref (_reply_message);
	return _result;
}


static gchar* icli_ipipe_proxy_get_video_processor (ICliIpipe* self, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	GVariant *_reply;
	GVariantIter _reply_iter;
	gchar* _result;
	GVariant* _tmp1_;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "com.ridgerun.ipiped.IpipeInterface", "GetVideoProcessor");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return NULL;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return NULL;
	}
	_reply = g_dbus_message_get_body (_reply_message);
	g_variant_iter_init (&_reply_iter, _reply);
	_tmp1_ = g_variant_iter_next_value (&_reply_iter);
	_result = g_variant_dup_string (_tmp1_, NULL);
	g_variant_unref (_tmp1_);
	g_object_unref (_reply_message);
	return _result;
}


static gchar* icli_ipipe_proxy_get_sensor (ICliIpipe* self, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	GVariant *_reply;
	GVariantIter _reply_iter;
	gchar* _result;
	GVariant* _tmp2_;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "com.ridgerun.ipiped.IpipeInterface", "GetSensor");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return NULL;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return NULL;
	}
	_reply = g_dbus_message_get_body (_reply_message);
	g_variant_iter_init (&_reply_iter, _reply);
	_tmp2_ = g_variant_iter_next_value (&_reply_iter);
	_result = g_variant_dup_string (_tmp2_, NULL);
	g_variant_unref (_tmp2_);
	g_object_unref (_reply_message);
	return _result;
}


static gint icli_ipipe_proxy_init_aew (ICliIpipe* self, const gchar* wb, const gchar* ae, const gchar* g, const gchar* meter, gint time, gint fps, gint segment_factor, gint width, gint height, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	GVariant *_reply;
	GVariantIter _reply_iter;
	gint _result;
	GVariant* _tmp3_;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "com.ridgerun.ipiped.IpipeInterface", "InitAew");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (wb));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (ae));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (g));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (meter));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (time));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (fps));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (segment_factor));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (width));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (height));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return 0;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return 0;
	}
	_reply = g_dbus_message_get_body (_reply_message);
	g_variant_iter_init (&_reply_iter, _reply);
	_tmp3_ = g_variant_iter_next_value (&_reply_iter);
	_result = g_variant_get_int32 (_tmp3_);
	g_variant_unref (_tmp3_);
	g_object_unref (_reply_message);
	return _result;
}


static void icli_ipipe_proxy_close_aew (ICliIpipe* self, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "com.ridgerun.ipiped.IpipeInterface", "CloseAew");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static void icli_ipipe_proxy_icli_ipipe_interface_init (ICliIpipeIface* iface) {
	iface->enable_debug = icli_ipipe_proxy_enable_debug;
	iface->ping = icli_ipipe_proxy_ping;
	iface->get_video_processor = icli_ipipe_proxy_get_video_processor;
	iface->get_sensor = icli_ipipe_proxy_get_sensor;
	iface->init_aew = icli_ipipe_proxy_init_aew;
	iface->close_aew = icli_ipipe_proxy_close_aew;
}


static void _dbus_icli_ipipe_enable_debug (ICliIpipe* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gboolean enable = FALSE;
	GVariant* _tmp4_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp4_ = g_variant_iter_next_value (&_arguments_iter);
	enable = g_variant_get_boolean (_tmp4_);
	g_variant_unref (_tmp4_);
	icli_ipipe_enable_debug (self, enable, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_icli_ipipe_ping (ICliIpipe* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gboolean result;
	g_variant_iter_init (&_arguments_iter, parameters);
	result = icli_ipipe_ping (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_boolean (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_icli_ipipe_get_video_processor (ICliIpipe* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gchar* result;
	g_variant_iter_init (&_arguments_iter, parameters);
	result = icli_ipipe_get_video_processor (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_string (result));
	_g_free0 ( result);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_icli_ipipe_get_sensor (ICliIpipe* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gchar* result;
	g_variant_iter_init (&_arguments_iter, parameters);
	result = icli_ipipe_get_sensor (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_string (result));
	_g_free0 ( result);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_icli_ipipe_init_aew (ICliIpipe* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* wb = NULL;
	GVariant* _tmp5_;
	gchar* ae = NULL;
	GVariant* _tmp6_;
	gchar* g = NULL;
	GVariant* _tmp7_;
	gchar* meter = NULL;
	GVariant* _tmp8_;
	gint time = 0;
	GVariant* _tmp9_;
	gint fps = 0;
	GVariant* _tmp10_;
	gint segment_factor = 0;
	GVariant* _tmp11_;
	gint width = 0;
	GVariant* _tmp12_;
	gint height = 0;
	GVariant* _tmp13_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gint result;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp5_ = g_variant_iter_next_value (&_arguments_iter);
	wb = g_variant_dup_string (_tmp5_, NULL);
	g_variant_unref (_tmp5_);
	_tmp6_ = g_variant_iter_next_value (&_arguments_iter);
	ae = g_variant_dup_string (_tmp6_, NULL);
	g_variant_unref (_tmp6_);
	_tmp7_ = g_variant_iter_next_value (&_arguments_iter);
	g = g_variant_dup_string (_tmp7_, NULL);
	g_variant_unref (_tmp7_);
	_tmp8_ = g_variant_iter_next_value (&_arguments_iter);
	meter = g_variant_dup_string (_tmp8_, NULL);
	g_variant_unref (_tmp8_);
	_tmp9_ = g_variant_iter_next_value (&_arguments_iter);
	time = g_variant_get_int32 (_tmp9_);
	g_variant_unref (_tmp9_);
	_tmp10_ = g_variant_iter_next_value (&_arguments_iter);
	fps = g_variant_get_int32 (_tmp10_);
	g_variant_unref (_tmp10_);
	_tmp11_ = g_variant_iter_next_value (&_arguments_iter);
	segment_factor = g_variant_get_int32 (_tmp11_);
	g_variant_unref (_tmp11_);
	_tmp12_ = g_variant_iter_next_value (&_arguments_iter);
	width = g_variant_get_int32 (_tmp12_);
	g_variant_unref (_tmp12_);
	_tmp13_ = g_variant_iter_next_value (&_arguments_iter);
	height = g_variant_get_int32 (_tmp13_);
	g_variant_unref (_tmp13_);
	result = icli_ipipe_init_aew (self, wb, ae, g, meter, time, fps, segment_factor, width, height, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_int32 (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (wb);
	_g_free0 (ae);
	_g_free0 (g);
	_g_free0 (meter);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_icli_ipipe_close_aew (ICliIpipe* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	icli_ipipe_close_aew (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void icli_ipipe_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "EnableDebug") == 0) {
		_dbus_icli_ipipe_enable_debug (object, parameters, invocation);
	} else if (strcmp (method_name, "Ping") == 0) {
		_dbus_icli_ipipe_ping (object, parameters, invocation);
	} else if (strcmp (method_name, "GetVideoProcessor") == 0) {
		_dbus_icli_ipipe_get_video_processor (object, parameters, invocation);
	} else if (strcmp (method_name, "GetSensor") == 0) {
		_dbus_icli_ipipe_get_sensor (object, parameters, invocation);
	} else if (strcmp (method_name, "InitAew") == 0) {
		_dbus_icli_ipipe_init_aew (object, parameters, invocation);
	} else if (strcmp (method_name, "CloseAew") == 0) {
		_dbus_icli_ipipe_close_aew (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* icli_ipipe_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean icli_ipipe_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


guint icli_ipipe_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_icli_ipipe_dbus_interface_info), &_icli_ipipe_dbus_interface_vtable, data, _icli_ipipe_unregister_object, error);
	if (!result) {
		return 0;
	}
	return result;
}


static void _icli_ipipe_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


/**
     * Constructor
     */
IpipeCli* ipipe_cli_construct (GType object_type, GError** error) {
	IpipeCli * self = NULL;
	ICliIpipe* _tmp0_ = NULL;
	ICliIpipe* _tmp1_;
	ICliIpipe* _tmp2_;
	GError * _inner_error_ = NULL;
	self = (IpipeCli*) g_object_new (object_type, NULL);
	_tmp0_ = g_initable_new (TYPE_ICLI_IPIPE_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "com.ridgerun.ipiped", "g-bus-type", G_BUS_TYPE_SYSTEM, "g-object-path", "/com/ridgerun/ipiped/ipipe", "g-interface-name", "com.ridgerun.ipiped.IpipeInterface", NULL);
	_tmp1_ = (ICliIpipe*) _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = _tmp1_;
	_g_object_unref0 (self->priv->ipipe);
	self->priv->ipipe = _tmp2_;
	return self;
}


IpipeCli* ipipe_cli_new (GError** error) {
	return ipipe_cli_construct (TYPE_IPIPE_CLI, error);
}


/**
     *Callback functions for the receiving signals
     */
void ipipe_cli_Error_cb (IpipeCli* self) {
	g_return_if_fail (self != NULL);
	fprintf (stdout, "Error signal received\n");
}


/**
     * Console Commands Functions
     */
static gint ipipe_cli_cli_enable_debug (IpipeCli* self, gchar** args, int args_length1) {
	gint result = 0;
	gboolean debug_enable = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	if (args[1] == NULL) {
		fprintf (stdout, "Error:\nMissing argument.Execute:'help <command>'\n");
		result = -1;
		return result;
	}
	if (g_strcmp0 (args[1], "true") == 0) {
		debug_enable = TRUE;
		ipipe_cli__debug = TRUE;
	} else {
		if (g_strcmp0 (args[1], "false") == 0) {
			debug_enable = FALSE;
			ipipe_cli__debug = FALSE;
		} else {
			fprintf (stderr, "Invalid argument value\n");
			result = -1;
			return result;
		}
	}
	icli_ipipe_enable_debug (self->priv->ipipe, debug_enable, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch0_g_io_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	goto __finally0;
	__catch0_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Fail to execute command:%s\n", e->message);
		result = -1;
		_g_error_free0 (e);
		return result;
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = 0;
	return result;
}


static gint ipipe_cli_cli_ping (IpipeCli* self, gchar** args, int args_length1) {
	gint result = 0;
	gboolean ret = FALSE;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = icli_ipipe_ping (self->priv->ipipe, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch1_g_error;
	}
	ret = _tmp1_;
	if (!ret) {
		result = -1;
		return result;
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Error:\nFailed to reach ipiped-daemon!\n");
		result = -1;
		_g_error_free0 (e);
		return result;
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	fprintf (stdout, "pong\n");
	result = 0;
	return result;
}


static gint ipipe_cli_cli_shell (IpipeCli* self, gchar** args, int args_length1) {
	gint result = 0;
	gchar** command = NULL;
	gint command_length1 = 0;
	gint _command_size_ = 0;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar** _tmp2_;
	gchar** _tmp3_ = NULL;
	gchar** _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_strjoinv (" ", args);
	_tmp1_ = _tmp0_;
	_tmp3_ = _tmp2_ = g_strsplit (_tmp1_, "\"", -1);
	_tmp4_ = _tmp3_;
	command = (_vala_array_free (command, command_length1, (GDestroyNotify) g_free), NULL);
	command_length1 = _vala_array_length (_tmp2_);
	_command_size_ = command_length1;
	command = _tmp4_;
	_g_free0 (_tmp1_);
	g_spawn_command_line_sync (command[1], NULL, NULL, NULL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_SPAWN_ERROR) {
			goto __catch2_g_spawn_error;
		}
		command = (_vala_array_free (command, command_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = 0;
	command = (_vala_array_free (command, command_length1, (GDestroyNotify) g_free), NULL);
	return result;
	goto __finally2;
	__catch2_g_spawn_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Fail to execute command:%s", e->message);
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		command = (_vala_array_free (command, command_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = -1;
	command = (_vala_array_free (command, command_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gint ipipe_cli_cli_get_video_processor (IpipeCli* self, gchar** args, int args_length1) {
	gint result = 0;
	gchar* ret = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = icli_ipipe_get_video_processor (self->priv->ipipe, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch3_g_error;
	}
	_tmp2_ = _tmp1_;
	_g_free0 (ret);
	ret = _tmp2_;
	if (ret == NULL) {
		result = -1;
		_g_free0 (ret);
		return result;
	} else {
		fprintf (stdout, "Video processor: %s\n", ret);
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Error:\nFailed to get video processor\n");
		result = -1;
		_g_error_free0 (e);
		_g_free0 (ret);
		return result;
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_g_free0 (ret);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = 0;
	_g_free0 (ret);
	return result;
}


static gint ipipe_cli_cli_get_sensor (IpipeCli* self, gchar** args, int args_length1) {
	gint result = 0;
	gchar* ret = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = icli_ipipe_get_sensor (self->priv->ipipe, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch4_g_error;
	}
	_tmp2_ = _tmp1_;
	_g_free0 (ret);
	ret = _tmp2_;
	if (ret == NULL) {
		result = -1;
		_g_free0 (ret);
		return result;
	} else {
		fprintf (stdout, "Sensor: %s\n", ret);
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Error:\nFailed to get video processor\n");
		result = -1;
		_g_error_free0 (e);
		_g_free0 (ret);
		return result;
	}
	__finally4:
	if (_inner_error_ != NULL) {
		_g_free0 (ret);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = 0;
	_g_free0 (ret);
	return result;
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static gint ipipe_cli_cli_run_config_script (IpipeCli* self, gchar** args, int args_length1) {
	gint result = 0;
	gchar* _tmp0_;
	gchar* dir;
	gchar* data = NULL;
	gchar* filename = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gint i = 0;
	FILE* _tmp3_ = NULL;
	FILE* file;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_strdup ("usr/share/ipiped/");
	dir = _tmp0_;
	if (args[1] == NULL) {
		fprintf (stdout, "Error:\nMissing argument.Execute:'help <command>'\n");
		result = -1;
		_g_free0 (filename);
		_g_free0 (data);
		_g_free0 (dir);
		return result;
	}
	_tmp1_ = g_strconcat (dir, args[1], NULL);
	_tmp2_ = _tmp1_;
	_g_free0 (filename);
	filename = _tmp2_;
	_tmp3_ = fopen (filename, "r");
	file = _tmp3_;
	if (file != NULL) {
		gchar line[128] = {0};
		while (TRUE) {
			const gchar* _tmp4_ = NULL;
			gchar* _tmp5_;
			gchar* _tmp6_;
			gchar** _tmp7_;
			gchar** _tmp8_ = NULL;
			gchar** s;
			gint s_length1;
			gint _s_size_;
			_tmp4_ = fgets (line, 128, file);
			_tmp5_ = g_strdup (_tmp4_);
			_tmp6_ = _tmp5_;
			_g_free0 (data);
			data = _tmp6_;
			if (!(data != NULL)) {
				break;
			}
			_tmp8_ = _tmp7_ = g_strsplit (data, " ", 10);
			s = _tmp8_;
			s_length1 = _vala_array_length (_tmp7_);
			_s_size_ = _vala_array_length (_tmp7_);
			{
				gboolean _tmp9_;
				i = 1;
				_tmp9_ = TRUE;
				while (TRUE) {
					gchar* _tmp10_ = NULL;
					gchar* _tmp11_;
					if (!_tmp9_) {
						i++;
					}
					_tmp9_ = FALSE;
					if (!(i < s_length1)) {
						break;
					}
					_tmp10_ = string_strip (s[i]);
					_tmp11_ = _tmp10_;
					_g_free0 (s[i]);
					s[i] = _tmp11_;
				}
			}
			command_manager_execute_cmd (self->cmd, s, s_length1);
			s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
		}
	} else {
		fprintf (stderr, "Configuration file %s doesn't exist\n", filename);
		result = -1;
		_fclose0 (file);
		_g_free0 (filename);
		_g_free0 (data);
		_g_free0 (dir);
		return result;
	}
	result = 0;
	_fclose0 (file);
	_g_free0 (filename);
	_g_free0 (data);
	_g_free0 (dir);
	return result;
}


static gint ipipe_cli_cli_ini_aew (IpipeCli* self, gchar** args, int args_length1) {
	gint result = 0;
	gint i;
	gint _tmp0_;
	gint wait_time;
	gint _tmp1_;
	gint min_fps;
	gint _tmp2_;
	gint width;
	gint _tmp3_;
	gint height;
	gint _tmp4_;
	gint segment_factor;
	gint _tmp5_;
	gint ret;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	i = 0;
	while (TRUE) {
		if (!(i < 10)) {
			break;
		}
		if (args[i] == NULL) {
			fprintf (stdout, "Error:\nMissing argument.Execute:'help <command>'\n");
			result = -1;
			return result;
		}
		i++;
	}
	_tmp0_ = atoi (args[5]);
	wait_time = _tmp0_;
	_tmp1_ = atoi (args[6]);
	min_fps = _tmp1_;
	_tmp2_ = atoi (args[8]);
	width = _tmp2_;
	_tmp3_ = atoi (args[9]);
	height = _tmp3_;
	_tmp4_ = atoi (args[7]);
	segment_factor = _tmp4_;
	_tmp5_ = icli_ipipe_init_aew (self->priv->ipipe, args[1], args[2], args[3], args[4], wait_time, min_fps, segment_factor, width, height, &_inner_error_);
	ret = _tmp5_;
	if (_inner_error_ != NULL) {
		goto __catch5_g_error;
	}
	if (ret < 0) {
		fprintf (stderr, "Error:\n Failed to initialize aew\n");
		result = -1;
		return result;
	} else {
		if (ipipe_cli__debug) {
			fprintf (stdout, "Ok.\n");
		}
		result = 0;
		return result;
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Fail to execute command:%s\n", e->message);
		result = -1;
		_g_error_free0 (e);
		return result;
	}
	__finally5:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return 0;
}


static gint ipipe_cli_cli_stop_aew (IpipeCli* self, gchar** args, int args_length1) {
	gint result = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	icli_ipipe_close_aew (self->priv->ipipe, &_inner_error_);
	if (_inner_error_ != NULL) {
		goto __catch6_g_error;
	}
	if (ipipe_cli__debug) {
		fprintf (stdout, "Ok.\n");
	}
	result = 0;
	return result;
	goto __finally6;
	__catch6_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Fail to execute command:%s\n", e->message);
		result = -1;
		_g_error_free0 (e);
		return result;
	}
	__finally6:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return 0;
}


static gint ipipe_cli_cli_exit (IpipeCli* self, gchar** args, int args_length1) {
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	self->priv->cli_enable = FALSE;
	if (ipipe_cli__debug) {
		fprintf (stdout, "Ok.\n");
	}
	result = 0;
	return result;
}


static gint _command_manager_command_help_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self) {
	gint result;
	result = command_manager_command_help (self, s, s_length1);
	return result;
}


static gint _ipipe_cli_cli_enable_debug_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self) {
	gint result;
	result = ipipe_cli_cli_enable_debug (self, s, s_length1);
	return result;
}


static gint _ipipe_cli_cli_ini_aew_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self) {
	gint result;
	result = ipipe_cli_cli_ini_aew (self, s, s_length1);
	return result;
}


static gint _ipipe_cli_cli_stop_aew_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self) {
	gint result;
	result = ipipe_cli_cli_stop_aew (self, s, s_length1);
	return result;
}


static gint _ipipe_cli_cli_shell_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self) {
	gint result;
	result = ipipe_cli_cli_shell (self, s, s_length1);
	return result;
}


static gint _ipipe_cli_cli_ping_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self) {
	gint result;
	result = ipipe_cli_cli_ping (self, s, s_length1);
	return result;
}


static gint _ipipe_cli_cli_exit_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self) {
	gint result;
	result = ipipe_cli_cli_exit (self, s, s_length1);
	return result;
}


static gint _ipipe_cli_cli_get_video_processor_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self) {
	gint result;
	result = ipipe_cli_cli_get_video_processor (self, s, s_length1);
	return result;
}


static gint _ipipe_cli_cli_get_sensor_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self) {
	gint result;
	result = ipipe_cli_cli_get_sensor (self, s, s_length1);
	return result;
}


static gint _ipipe_cli_cli_run_config_script_ipipe_command_cmd_func (gchar** s, int s_length1, gpointer self) {
	gint result;
	result = ipipe_cli_cli_run_config_script (self, s, s_length1);
	return result;
}


static void ipipe_cli_initialize_cmd_array (IpipeCli* self) {
	g_return_if_fail (self != NULL);
	command_manager_new_command (self->cmd, "help", _command_manager_command_help_ipipe_command_cmd_func, self->cmd, "help [<command>]", "Displays the help text for all the posible commands or a specific " "command", "");
	command_manager_new_command (self->cmd, "set-debug", _ipipe_cli_cli_enable_debug_ipipe_command_cmd_func, self, "set_debug <true/false>", "Enable/Disable debug messages", "\n\ttrue: enables debug, " "\n\tfalse: disables debug");
	command_manager_new_command (self->cmd, "init-aew", _ipipe_cli_cli_ini_aew_ipipe_command_cmd_func, self, "init-aew <WB> <AE> <G> <EM> " "<T[us]> <fps> <seg> <width> <height>", "Initialize AEW algorithms", "\n\tWB: white balance algorithm, the options are:" "\n\t\tG -for gray world algorithm" "\n\t\tW -for retinex algorithm" "\n\t\tN -for none" "\n\tAE: auto exposure algorithm, the options are" "\n\t\tEC -for electronic centric" "\n\t\tN -for none" "\n\tG: gain type, the options are: " "\n\t\tS -to use the sensor gain " "\n\t\tD -to use the digital" "\n\tEM: exposure metering method, the options are:" "\n\t\tS -for spot metering that take into account the ligth " "\n\t\tinformation of a small portion in the center of the " "\n\t\tframe and the rest is ignored" "\n\t\tP -for partial metering that take into account the " "\n\t\tligth information of a larger portion in the center " "\n\t\tof the frame (10% - 15%) and the rest of the frame is " "ignored." "\n\t\tC -for center weighted metering that take into account " "\n\t\tthe ligth information coming from the entire frame with " "\n\t\temphasis placed on the center area" "\n\t\tA -for average metering that take into account the ligth " "\n\t\tinformation from the entire frame without weighting" "\n\t\tSG -for segmented metering that divides the frame " "\n\t\ton 6 pieces and weighting them to avoid backlighting" "\n\tT: wait time in us, especifies the time between " "\n\t\talgorithm ajustments, max value=1s=1000000us" "\n\tfps: minimun frame rate" "\n\tseg: frame segmentation factor, each frame is segmented into " "\n\t\tregions, this factor represents the percentage of the " "\n\t\tmaximun number of posible regions" "\n\twidth: captured video/image horizontal size" "\n\theight: captured video/image vertical size");
	command_manager_new_command (self->cmd, "stop-aew", _ipipe_cli_cli_stop_aew_ipipe_command_cmd_func, self, "stop-aew", "End AEW algorithm", "");
	command_manager_new_command (self->cmd, "shell", _ipipe_cli_cli_shell_ipipe_command_cmd_func, self, "shell <\"shell_cmd\">", "Execute a shell command(shell_cmd) using interactive console", "");
	command_manager_new_command (self->cmd, "ping", _ipipe_cli_cli_ping_ipipe_command_cmd_func, self, "ping", "Show if ipipe-daemon is alive", "");
	command_manager_new_command (self->cmd, "quit", _ipipe_cli_cli_exit_ipipe_command_cmd_func, self, "quit", "Quit from the interactive console", "");
	command_manager_new_command (self->cmd, "exit", _ipipe_cli_cli_exit_ipipe_command_cmd_func, self, "exit", "Exit from the interactive console", "");
	command_manager_new_command (self->cmd, "get-video-processor", _ipipe_cli_cli_get_video_processor_ipipe_command_cmd_func, self, "get-video-processor", "Show the video processor that is being used", "");
	command_manager_new_command (self->cmd, "get-sensor", _ipipe_cli_cli_get_sensor_ipipe_command_cmd_func, self, "get-sensor", "Show the sensor that is being used", "");
	command_manager_new_command (self->cmd, "run-config-script", _ipipe_cli_cli_run_config_script_ipipe_command_cmd_func, self, "run-config-script <script>", "Execute a group of ipipe-client commands", "\n\tscript: is the name of script");
}


/**
     *Parse entry-options or flags:
     *_cmd_name:   Command name in which 'help' description
     *           will be display
     *
     *_debug:               flag to enable debug information
     * 
     *_remaining_args:  command to be executed remains here,
     *                  if there is no remaining args interactive
     *                  console is enable.
     */
gboolean ipipe_cli_parse_options (IpipeCli* self, gchar** args, int args_length1) {
	gboolean result = FALSE;
	gchar* _tmp0_;
	gchar** _tmp1_;
	GOptionContext* _tmp2_ = NULL;
	GOptionContext* opt;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = NULL;
	_g_free0 (ipipe_cli__cmd_name);
	ipipe_cli__cmd_name = _tmp0_;
	ipipe_cli__debug = FALSE;
	_tmp1_ = NULL;
	ipipe_cli__remaining_args = (_vala_array_free (ipipe_cli__remaining_args, _vala_array_length (ipipe_cli__remaining_args), (GDestroyNotify) g_free), NULL);
	ipipe_cli__remaining_args = _tmp1_;
	_tmp2_ = g_option_context_new ("(For Commands HELP: 'ipipe-client help')");
	opt = _tmp2_;
	g_option_context_set_help_enabled (opt, TRUE);
	g_option_context_add_main_entries (opt, IPIPE_CLI_options, NULL);
	g_option_context_parse (opt, &args_length1, &args, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_OPTION_ERROR) {
			goto __catch7_g_option_error;
		}
		_g_option_context_free0 (opt);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (ipipe_cli__cmd_name != NULL) {
		gchar* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp5_;
		gchar** _tmp6_ = NULL;
		gchar** _tmp7_;
		gint _tmp7__length1;
		self->priv->cli_enable = FALSE;
		_tmp3_ = g_strdup ("help");
		_tmp4_ = g_strdup (ipipe_cli__cmd_name);
		_tmp5_ = g_strdup ("\0");
		_tmp6_ = g_new0 (gchar*, 3 + 1);
		_tmp6_[0] = _tmp3_;
		_tmp6_[1] = _tmp4_;
		_tmp6_[2] = _tmp5_;
		_tmp7_ = _tmp6_;
		_tmp7__length1 = 3;
		command_manager_command_help (self->cmd, _tmp7_, 3);
		_tmp7_ = (_vala_array_free (_tmp7_, _tmp7__length1, (GDestroyNotify) g_free), NULL);
	}
	goto __finally7;
	__catch7_g_option_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "OptionError failure: %s. See 'ipipe-client --help'\n", e->message);
		result = FALSE;
		_g_error_free0 (e);
		_g_option_context_free0 (opt);
		return result;
	}
	__finally7:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (opt);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	_g_option_context_free0 (opt);
	return result;
}


/**
     *Interactive Console management
     */
static gchar* __readline (const gchar* prompt) {
	gchar* result = NULL;
	void* _tmp0_ = NULL;
	void* cstr;
	gchar* _tmp1_ = NULL;
	gchar* str;
	_tmp0_ = readline (prompt);
	cstr = _tmp0_;
	if (cstr == NULL) {
		result = NULL;
		return result;
	}
	_tmp1_ = g_strdup ((const gchar*) cstr);
	str = _tmp1_;
	free (cstr);
	result = str;
	return result;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	result = ((gchar*) self)[index];
	return result;
}


gboolean ipipe_cli_parse_cmd (IpipeCli* self, gchar** rem_args, int rem_args_length1, GError** error) {
	gboolean result = FALSE;
	gchar** args = NULL;
	gint args_length1 = 0;
	gint _args_size_ = 0;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* home;
	gchar* _tmp2_;
	gchar* _tmp12_;
	g_return_val_if_fail (self != NULL, FALSE);
	if (rem_args != NULL) {
		command_manager_execute_cmd (self->cmd, rem_args, rem_args_length1);
		self->priv->cli_enable = FALSE;
	}
	_tmp0_ = g_getenv ("HOME");
	_tmp1_ = g_strdup (_tmp0_);
	home = _tmp1_;
	_tmp2_ = g_strconcat (home, "/.ipipe-client_history", NULL);
	read_history (_tmp2_);
	_g_free0 (_tmp2_);
	while (TRUE) {
		gboolean _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* cmd_line;
		_tmp3_ = feof (stdin);
		if (!(!_tmp3_)) {
			break;
		}
		if (!self->priv->cli_enable) {
			break;
		}
		_tmp4_ = __readline ("ipipe-client$ ");
		cmd_line = _tmp4_;
		if (cmd_line != NULL) {
			gchar* _tmp5_ = NULL;
			gchar* _tmp6_;
			gchar** _tmp7_;
			gchar** _tmp8_ = NULL;
			gchar** _tmp9_;
			gboolean _tmp10_ = FALSE;
			add_history (cmd_line);
			_tmp5_ = string_strip (cmd_line);
			_tmp6_ = _tmp5_;
			_g_free0 (_tmp6_);
			_tmp8_ = _tmp7_ = g_strsplit (cmd_line, " ", -1);
			_tmp9_ = _tmp8_;
			args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
			args_length1 = _vala_array_length (_tmp7_);
			_args_size_ = args_length1;
			args = _tmp9_;
			if (args[0] != NULL) {
				gchar _tmp11_;
				_tmp11_ = string_get (cmd_line, (glong) 0);
				_tmp10_ = _tmp11_ != '#';
			} else {
				_tmp10_ = FALSE;
			}
			if (_tmp10_) {
				command_manager_execute_cmd (self->cmd, args, args_length1);
			}
		}
		_g_free0 (cmd_line);
	}
	_tmp12_ = g_strconcat (home, "/.ipipe-client_history", NULL);
	write_history (_tmp12_);
	_g_free0 (_tmp12_);
	result = TRUE;
	_g_free0 (home);
	args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


gboolean ipipe_cli_parse_config (IpipeCli* self, IpipeCli* cli, GError** error) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	gchar* sensor;
	gchar* _tmp1_ = NULL;
	gchar* video_processor;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (cli != NULL, FALSE);
	_tmp0_ = icli_ipipe_get_sensor (self->priv->ipipe, &_inner_error_);
	sensor = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	_tmp1_ = icli_ipipe_get_video_processor (self->priv->ipipe, &_inner_error_);
	video_processor = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (sensor);
			return FALSE;
		} else {
			_g_free0 (sensor);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	if (g_strcmp0 (video_processor, "dm365") == 0) {
		cli_dm365ipipe* _tmp2_ = NULL;
		cli_dm365ipipe* video_processor_obj;
		AbstcCliRegister* _tmp3_;
		AbstcCliRegister* _tmp4_;
		_tmp2_ = cli_dm365ipipe_new (ipipe_cli__debug, &_inner_error_);
		video_processor_obj = _tmp2_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_IO_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (video_processor);
				_g_free0 (sensor);
				return FALSE;
			} else {
				_g_free0 (video_processor);
				_g_free0 (sensor);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		}
		abstc_cli_register_registration ((AbstcCliRegister*) video_processor_obj, cli, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_IO_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (video_processor_obj);
				_g_free0 (video_processor);
				_g_free0 (sensor);
				return FALSE;
			} else {
				_g_object_unref0 (video_processor_obj);
				_g_free0 (video_processor);
				_g_free0 (sensor);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		}
		_tmp3_ = _g_object_ref0 ((AbstcCliRegister*) video_processor_obj);
		_tmp4_ = _tmp3_;
		_g_object_unref0 (self->priv->video_processor_i);
		self->priv->video_processor_i = _tmp4_;
		_g_object_unref0 (video_processor_obj);
	} else {
		fprintf (stderr, "Video processor doesn't match with available platforms \n");
		result = FALSE;
		_g_free0 (video_processor);
		_g_free0 (sensor);
		return result;
	}
	if (g_strcmp0 (sensor, "mt9p031") == 0) {
		cli_mt9p031* _tmp5_ = NULL;
		cli_mt9p031* sensor_obj;
		AbstcCliRegister* _tmp6_;
		AbstcCliRegister* _tmp7_;
		_tmp5_ = cli_mt9p031_new (ipipe_cli__debug);
		sensor_obj = _tmp5_;
		abstc_cli_register_registration ((AbstcCliRegister*) sensor_obj, cli, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_IO_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (sensor_obj);
				_g_free0 (video_processor);
				_g_free0 (sensor);
				return FALSE;
			} else {
				_g_object_unref0 (sensor_obj);
				_g_free0 (video_processor);
				_g_free0 (sensor);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		}
		_tmp6_ = _g_object_ref0 ((AbstcCliRegister*) sensor_obj);
		_tmp7_ = _tmp6_;
		_g_object_unref0 (self->priv->sensor_i);
		self->priv->sensor_i = _tmp7_;
		_g_object_unref0 (sensor_obj);
	} else {
		fprintf (stderr, "Sensor support doesn't exist \n");
		result = FALSE;
		_g_free0 (video_processor);
		_g_free0 (sensor);
		return result;
	}
	result = TRUE;
	_g_free0 (video_processor);
	_g_free0 (sensor);
	return result;
}


static gint ipipe_cli_main (gchar** args, int args_length1) {
	gint result = 0;
	IpipeCli* cli = NULL;
	IpipeCli* _tmp0_ = NULL;
	IpipeCli* _tmp1_;
	IpipeCli* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	gboolean _tmp6_;
	gboolean _tmp7_;
	GError * _inner_error_ = NULL;
	_tmp0_ = ipipe_cli_new (&_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch8_g_io_error;
		}
		_g_object_unref0 (cli);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp2_ = _tmp1_;
	_g_object_unref0 (cli);
	cli = _tmp2_;
	ipipe_cli_initialize_cmd_array (cli);
	_tmp3_ = ipipe_cli_parse_options (cli, args, args_length1);
	if (!_tmp3_) {
		result = -1;
		_g_object_unref0 (cli);
		return result;
	}
	_tmp4_ = ipipe_cli_parse_config (cli, cli, &_inner_error_);
	_tmp5_ = _tmp4_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch8_g_io_error;
		}
		_g_object_unref0 (cli);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	if (!_tmp5_) {
		result = -1;
		_g_object_unref0 (cli);
		return result;
	}
	_tmp6_ = ipipe_cli_parse_cmd (cli, ipipe_cli__remaining_args, _vala_array_length (ipipe_cli__remaining_args), &_inner_error_);
	_tmp7_ = _tmp6_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch8_g_io_error;
		}
		_g_object_unref0 (cli);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	if (!_tmp7_) {
		result = -1;
		_g_object_unref0 (cli);
		return result;
	}
	goto __finally8;
	__catch8_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "ipipe-client> DBus failure: %s\n", e->message);
		result = 1;
		_g_error_free0 (e);
		_g_object_unref0 (cli);
		return result;
	}
	__finally8:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (cli);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = 0;
	_g_object_unref0 (cli);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return ipipe_cli_main (argv, argc);
}


static void ipipe_cli_class_init (IpipeCliClass * klass) {
	ipipe_cli_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (IpipeCliPrivate));
	G_OBJECT_CLASS (klass)->finalize = ipipe_cli_finalize;
}


static void ipipe_cli_instance_init (IpipeCli * self) {
	CommandManager* _tmp0_ = NULL;
	self->priv = IPIPE_CLI_GET_PRIVATE (self);
	self->priv->cli_enable = TRUE;
	_tmp0_ = command_manager_new ();
	self->cmd = _tmp0_;
}


static void ipipe_cli_finalize (GObject* obj) {
	IpipeCli * self;
	self = IPIPE_CLI (obj);
	_g_object_unref0 (self->cmd);
	_g_object_unref0 (self->priv->ipipe);
	_g_object_unref0 (self->priv->video_processor_i);
	_g_object_unref0 (self->priv->sensor_i);
	G_OBJECT_CLASS (ipipe_cli_parent_class)->finalize (obj);
}


GType ipipe_cli_get_type (void) {
	static volatile gsize ipipe_cli_type_id__volatile = 0;
	if (g_once_init_enter (&ipipe_cli_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IpipeCliClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ipipe_cli_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IpipeCli), 0, (GInstanceInitFunc) ipipe_cli_instance_init, NULL };
		GType ipipe_cli_type_id;
		ipipe_cli_type_id = g_type_register_static (G_TYPE_OBJECT, "IpipeCli", &g_define_type_info, 0);
		g_once_init_leave (&ipipe_cli_type_id__volatile, ipipe_cli_type_id);
	}
	return ipipe_cli_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



