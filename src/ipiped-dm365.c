/* ipiped-dm365.c generated by valac 0.12.0, the Vala compiler
 * generated from ipiped-dm365.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <rraew.h>
#include <gio/gio.h>
#include <string.h>
#include <media/davinci/imp_common.h>
#include <media/davinci/imp_previewer.h>
#include <media/davinci/dm365_ipipe.h>
#include <media/davinci/dm3xx_ipipe.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <stropts.h>
#include <unistd.h>
#include <float.h>
#include <math.h>


#define TYPE_ABSTC_VIDEO_PROCESSOR (abstc_video_processor_get_type ())
#define ABSTC_VIDEO_PROCESSOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ABSTC_VIDEO_PROCESSOR, AbstcVideoProcessor))
#define ABSTC_VIDEO_PROCESSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ABSTC_VIDEO_PROCESSOR, AbstcVideoProcessorClass))
#define IS_ABSTC_VIDEO_PROCESSOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ABSTC_VIDEO_PROCESSOR))
#define IS_ABSTC_VIDEO_PROCESSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ABSTC_VIDEO_PROCESSOR))
#define ABSTC_VIDEO_PROCESSOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ABSTC_VIDEO_PROCESSOR, AbstcVideoProcessorClass))

typedef struct _AbstcVideoProcessor AbstcVideoProcessor;
typedef struct _AbstcVideoProcessorClass AbstcVideoProcessorClass;
typedef struct _AbstcVideoProcessorPrivate AbstcVideoProcessorPrivate;

#define TYPE_IPIPED_DM365 (ipiped_dm365_get_type ())
#define IPIPED_DM365(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IPIPED_DM365, Ipiped_dm365))
#define IPIPED_DM365_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IPIPED_DM365, Ipiped_dm365Class))
#define IS_IPIPED_DM365(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IPIPED_DM365))
#define IS_IPIPED_DM365_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IPIPED_DM365))
#define IPIPED_DM365_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IPIPED_DM365, Ipiped_dm365Class))

typedef struct _Ipiped_dm365 Ipiped_dm365;
typedef struct _Ipiped_dm365Class Ipiped_dm365Class;
typedef struct _Ipiped_dm365Private Ipiped_dm365Private;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _AbstcVideoProcessor {
	GObject parent_instance;
	AbstcVideoProcessorPrivate * priv;
	gint previewer_fd;
	gint aew_fd;
	gchar owner_previewer_fd;
	gchar owner_aew_fd;
};

struct _AbstcVideoProcessorClass {
	GObjectClass parent_class;
	gboolean (*get_video_processor_data) (AbstcVideoProcessor* self, struct rraew_interface* interf);
};

struct _Ipiped_dm365 {
	AbstcVideoProcessor parent_instance;
	Ipiped_dm365Private * priv;
};

struct _Ipiped_dm365Class {
	AbstcVideoProcessorClass parent_class;
};


static gpointer ipiped_dm365_parent_class = NULL;
static gboolean ipiped_dm365_initialized;
static gboolean ipiped_dm365_initialized = FALSE;
extern gboolean abstc_video_processor_debug;

GType abstc_video_processor_get_type (void) G_GNUC_CONST;
GType ipiped_dm365_get_type (void) G_GNUC_CONST;
guint ipiped_dm365_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
enum  {
	IPIPED_DM365_DUMMY_PROPERTY
};
Ipiped_dm365* ipiped_dm365_new (void);
Ipiped_dm365* ipiped_dm365_construct (GType object_type);
AbstcVideoProcessor* abstc_video_processor_construct (GType object_type);
gboolean ipiped_dm365_set_previewer_mode (Ipiped_dm365* self, const gchar* mode_s, GError** error);
static gboolean ipiped_dm365_set_previewer_config (Ipiped_dm365* self, struct prev_channel_config* chan_config);
static gboolean ipiped_dm365_get_previewer_config (Ipiped_dm365* self, struct prev_channel_config* chan_config);
gboolean ipiped_dm365_set_color_pattern (Ipiped_dm365* self, const gchar* colorptn, GError** error);
static void ipiped_dm365_convertion_gains_from_q10 (Ipiped_dm365* self, guint32 gain, gint* decimal_gain, gint* integer_gain);
static void ipiped_dm365_convertion_gains_to_q10 (Ipiped_dm365* self, guint32* gain, gint decimal_gain, gint integer_gain);
static gboolean ipiped_dm365_set_digital_gain_i (Ipiped_dm365* self, gint* previewer_fd, gchar* owner_previewer_fd, guint32 q10r_gain, guint32 q10g_gain, guint32 q10b_gain);
gboolean ipiped_dm365_set_digital_gain (Ipiped_dm365* self, gdouble _red_gain, gdouble _green_gain, gdouble _blue_gain, GError** error);
static gboolean ipiped_dm365_get_digital_gain_i (Ipiped_dm365* self, gint* previewer_fd, gchar* owner_previewer_fd, guint32* red_gain, guint32* green_gain, guint32* blue_gain);
gboolean ipiped_dm365_get_digital_gain (Ipiped_dm365* self, gdouble* _red_gain, gdouble* _green_gain, gdouble* _blue_gain, GError** error);
gboolean ipiped_dm365_set_luminance_adj (Ipiped_dm365* self, gint bright, gdouble contr, GError** error);
gboolean ipiped_dm365_get_luminance_adj (Ipiped_dm365* self, gint* bright, gdouble* contr, GError** error);
static gboolean ipiped_dm365_real_get_video_processor_data (AbstcVideoProcessor* base, struct rraew_interface* interf);
static void ipiped_dm365_finalize (GObject* obj);
static void _dbus_ipiped_dm365_set_previewer_mode (Ipiped_dm365* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipiped_dm365_set_color_pattern (Ipiped_dm365* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipiped_dm365_set_digital_gain (Ipiped_dm365* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipiped_dm365_get_digital_gain (Ipiped_dm365* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipiped_dm365_set_luminance_adj (Ipiped_dm365* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipiped_dm365_get_luminance_adj (Ipiped_dm365* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void ipiped_dm365_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* ipiped_dm365_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean ipiped_dm365_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _ipiped_dm365_unregister_object (gpointer user_data);

static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_set_previewer_mode_mode_s = {-1, "mode_s", "s"};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_set_previewer_mode_result = {-1, "result", "b"};
static const GDBusArgInfo * const _ipiped_dm365_dbus_arg_info_set_previewer_mode_in[] = {&_ipiped_dm365_dbus_arg_info_set_previewer_mode_mode_s, NULL};
static const GDBusArgInfo * const _ipiped_dm365_dbus_arg_info_set_previewer_mode_out[] = {&_ipiped_dm365_dbus_arg_info_set_previewer_mode_result, NULL};
static const GDBusMethodInfo _ipiped_dm365_dbus_method_info_set_previewer_mode = {-1, "SetPreviewerMode", (GDBusArgInfo **) (&_ipiped_dm365_dbus_arg_info_set_previewer_mode_in), (GDBusArgInfo **) (&_ipiped_dm365_dbus_arg_info_set_previewer_mode_out)};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_set_color_pattern_colorptn = {-1, "colorptn", "s"};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_set_color_pattern_result = {-1, "result", "b"};
static const GDBusArgInfo * const _ipiped_dm365_dbus_arg_info_set_color_pattern_in[] = {&_ipiped_dm365_dbus_arg_info_set_color_pattern_colorptn, NULL};
static const GDBusArgInfo * const _ipiped_dm365_dbus_arg_info_set_color_pattern_out[] = {&_ipiped_dm365_dbus_arg_info_set_color_pattern_result, NULL};
static const GDBusMethodInfo _ipiped_dm365_dbus_method_info_set_color_pattern = {-1, "SetColorPattern", (GDBusArgInfo **) (&_ipiped_dm365_dbus_arg_info_set_color_pattern_in), (GDBusArgInfo **) (&_ipiped_dm365_dbus_arg_info_set_color_pattern_out)};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_set_digital_gain__red_gain = {-1, "_red_gain", "d"};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_set_digital_gain__green_gain = {-1, "_green_gain", "d"};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_set_digital_gain__blue_gain = {-1, "_blue_gain", "d"};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_set_digital_gain_result = {-1, "result", "b"};
static const GDBusArgInfo * const _ipiped_dm365_dbus_arg_info_set_digital_gain_in[] = {&_ipiped_dm365_dbus_arg_info_set_digital_gain__red_gain, &_ipiped_dm365_dbus_arg_info_set_digital_gain__green_gain, &_ipiped_dm365_dbus_arg_info_set_digital_gain__blue_gain, NULL};
static const GDBusArgInfo * const _ipiped_dm365_dbus_arg_info_set_digital_gain_out[] = {&_ipiped_dm365_dbus_arg_info_set_digital_gain_result, NULL};
static const GDBusMethodInfo _ipiped_dm365_dbus_method_info_set_digital_gain = {-1, "SetDigitalGain", (GDBusArgInfo **) (&_ipiped_dm365_dbus_arg_info_set_digital_gain_in), (GDBusArgInfo **) (&_ipiped_dm365_dbus_arg_info_set_digital_gain_out)};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_get_digital_gain__red_gain = {-1, "_red_gain", "d"};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_get_digital_gain__green_gain = {-1, "_green_gain", "d"};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_get_digital_gain__blue_gain = {-1, "_blue_gain", "d"};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_get_digital_gain_result = {-1, "result", "b"};
static const GDBusArgInfo * const _ipiped_dm365_dbus_arg_info_get_digital_gain_in[] = {NULL};
static const GDBusArgInfo * const _ipiped_dm365_dbus_arg_info_get_digital_gain_out[] = {&_ipiped_dm365_dbus_arg_info_get_digital_gain__red_gain, &_ipiped_dm365_dbus_arg_info_get_digital_gain__green_gain, &_ipiped_dm365_dbus_arg_info_get_digital_gain__blue_gain, &_ipiped_dm365_dbus_arg_info_get_digital_gain_result, NULL};
static const GDBusMethodInfo _ipiped_dm365_dbus_method_info_get_digital_gain = {-1, "GetDigitalGain", (GDBusArgInfo **) (&_ipiped_dm365_dbus_arg_info_get_digital_gain_in), (GDBusArgInfo **) (&_ipiped_dm365_dbus_arg_info_get_digital_gain_out)};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_set_luminance_adj_bright = {-1, "bright", "i"};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_set_luminance_adj_contr = {-1, "contr", "d"};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_set_luminance_adj_result = {-1, "result", "b"};
static const GDBusArgInfo * const _ipiped_dm365_dbus_arg_info_set_luminance_adj_in[] = {&_ipiped_dm365_dbus_arg_info_set_luminance_adj_bright, &_ipiped_dm365_dbus_arg_info_set_luminance_adj_contr, NULL};
static const GDBusArgInfo * const _ipiped_dm365_dbus_arg_info_set_luminance_adj_out[] = {&_ipiped_dm365_dbus_arg_info_set_luminance_adj_result, NULL};
static const GDBusMethodInfo _ipiped_dm365_dbus_method_info_set_luminance_adj = {-1, "SetLuminanceAdj", (GDBusArgInfo **) (&_ipiped_dm365_dbus_arg_info_set_luminance_adj_in), (GDBusArgInfo **) (&_ipiped_dm365_dbus_arg_info_set_luminance_adj_out)};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_get_luminance_adj_bright = {-1, "bright", "i"};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_get_luminance_adj_contr = {-1, "contr", "d"};
static const GDBusArgInfo _ipiped_dm365_dbus_arg_info_get_luminance_adj_result = {-1, "result", "b"};
static const GDBusArgInfo * const _ipiped_dm365_dbus_arg_info_get_luminance_adj_in[] = {NULL};
static const GDBusArgInfo * const _ipiped_dm365_dbus_arg_info_get_luminance_adj_out[] = {&_ipiped_dm365_dbus_arg_info_get_luminance_adj_bright, &_ipiped_dm365_dbus_arg_info_get_luminance_adj_contr, &_ipiped_dm365_dbus_arg_info_get_luminance_adj_result, NULL};
static const GDBusMethodInfo _ipiped_dm365_dbus_method_info_get_luminance_adj = {-1, "GetLuminanceAdj", (GDBusArgInfo **) (&_ipiped_dm365_dbus_arg_info_get_luminance_adj_in), (GDBusArgInfo **) (&_ipiped_dm365_dbus_arg_info_get_luminance_adj_out)};
static const GDBusMethodInfo * const _ipiped_dm365_dbus_method_info[] = {&_ipiped_dm365_dbus_method_info_set_previewer_mode, &_ipiped_dm365_dbus_method_info_set_color_pattern, &_ipiped_dm365_dbus_method_info_set_digital_gain, &_ipiped_dm365_dbus_method_info_get_digital_gain, &_ipiped_dm365_dbus_method_info_set_luminance_adj, &_ipiped_dm365_dbus_method_info_get_luminance_adj, NULL};
static const GDBusSignalInfo * const _ipiped_dm365_dbus_signal_info[] = {NULL};
static const GDBusPropertyInfo * const _ipiped_dm365_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _ipiped_dm365_dbus_interface_info = {-1, "com.ridgerun.dm365ipipeInterface", (GDBusMethodInfo **) (&_ipiped_dm365_dbus_method_info), (GDBusSignalInfo **) (&_ipiped_dm365_dbus_signal_info), (GDBusPropertyInfo **) (&_ipiped_dm365_dbus_property_info)};
static const GDBusInterfaceVTable _ipiped_dm365_dbus_interface_vtable = {ipiped_dm365_dbus_interface_method_call, ipiped_dm365_dbus_interface_get_property, ipiped_dm365_dbus_interface_set_property};

/**
     * Create a new instance of a Ipipe daemon
     */
Ipiped_dm365* ipiped_dm365_construct (GType object_type) {
	Ipiped_dm365 * self = NULL;
	self = (Ipiped_dm365*) abstc_video_processor_construct (object_type);
	ipiped_dm365_initialized = FALSE;
	abstc_video_processor_debug = FALSE;
	((AbstcVideoProcessor*) self)->previewer_fd = -1;
	((AbstcVideoProcessor*) self)->aew_fd = -1;
	((AbstcVideoProcessor*) self)->owner_previewer_fd = (gchar) 1;
	((AbstcVideoProcessor*) self)->owner_aew_fd = (gchar) 1;
	return self;
}


Ipiped_dm365* ipiped_dm365_new (void) {
	return ipiped_dm365_construct (TYPE_IPIPED_DM365);
}


/**
     * Configure the previewer mode with the default configuration
     * @param mode_s indicates if configure the previewer on continuos 
     * mode or single shot mode
     */
gboolean ipiped_dm365_set_previewer_mode (Ipiped_dm365* self, const gchar* mode_s, GError** error) {
	gboolean result = FALSE;
	struct prev_channel_config chan_config = {0};
	guint mode = 0U;
	gint _tmp0_;
	gint _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (mode_s != NULL, FALSE);
	memset (&chan_config, 0, sizeof (struct prev_channel_config));
	((AbstcVideoProcessor*) self)->owner_previewer_fd = (gchar) 0;
	if (g_strcmp0 (mode_s, "cont") == 0) {
		mode = (guint) IMP_MODE_CONTINUOUS;
	} else {
		if (g_strcmp0 (mode_s, "one-shot") == 0) {
			mode = (guint) PREV_MODE_SINGLE_SHOT;
		} else {
			fprintf (stderr, "Ipiped: Invalid previewer operation mode\n");
			result = FALSE;
			return result;
		}
	}
	if (ipiped_dm365_initialized) {
		if (abstc_video_processor_debug) {
			fprintf (stderr, "Ipiped:Previewer is already configured\n");
		}
		result = TRUE;
		return result;
	}
	_tmp0_ = open ("/dev/davinci_previewer", O_RDWR, (mode_t) 0);
	((AbstcVideoProcessor*) self)->previewer_fd = _tmp0_;
	if (((AbstcVideoProcessor*) self)->previewer_fd < 0) {
		result = FALSE;
		return result;
	}
	_tmp1_ = ioctl (((AbstcVideoProcessor*) self)->previewer_fd, PREV_S_OPER_MODE, &mode);
	if (_tmp1_ < 0) {
		if (abstc_video_processor_debug) {
			fprintf (stderr, "Ipiped:Fail to set operation mode\n");
		}
		result = FALSE;
		return result;
	}
	chan_config.oper_mode = mode;
	chan_config.len = (gushort) 0;
	chan_config.config = NULL;
	ipiped_dm365_set_previewer_config (self, &chan_config);
	ipiped_dm365_initialized = TRUE;
	result = TRUE;
	return result;
}


static gboolean ipiped_dm365_set_previewer_config (Ipiped_dm365* self, struct prev_channel_config* chan_config) {
	gboolean result = FALSE;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = ioctl (((AbstcVideoProcessor*) self)->previewer_fd, PREV_S_CONFIG, chan_config);
	if (_tmp0_ < 0) {
		if (abstc_video_processor_debug) {
			fprintf (stderr, "Ipiped:Fail to set configuration\n");
		}
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


static gboolean ipiped_dm365_get_previewer_config (Ipiped_dm365* self, struct prev_channel_config* chan_config) {
	gboolean result = FALSE;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = ioctl (((AbstcVideoProcessor*) self)->previewer_fd, PREV_G_CONFIG, chan_config);
	if (_tmp0_ < 0) {
		if (abstc_video_processor_debug) {
			fprintf (stderr, "Ipiped:Fail to get configuration\n");
		}
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


/**
     * Set color pattern
     * Configure in the previewer the color pattern passed by the user
     * @param   colorptn is a string that represents the RGB color order*/
gboolean ipiped_dm365_set_color_pattern (Ipiped_dm365* self, const gchar* colorptn, GError** error) {
	gboolean result = FALSE;
	struct prev_channel_config chan_config = {0};
	struct prev_continuous_config prev_config = {0};
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (colorptn != NULL, FALSE);
	memset (&chan_config, 0, sizeof (struct prev_channel_config));
	memset (&prev_config, 0, sizeof (struct prev_continuous_config));
	chan_config.oper_mode = (guint) IMP_MODE_CONTINUOUS;
	chan_config.len = (gushort) sizeof (struct prev_continuous_config);
	chan_config.config = &prev_config;
	ipiped_dm365_get_previewer_config (self, &chan_config);
	if (g_strcmp0 (colorptn, "GrRBGb") == 0) {
		prev_config.input.colp_olop = IPIPE_GREEN_RED;
		prev_config.input.colp_olep = IPIPE_RED;
		prev_config.input.colp_elop = IPIPE_BLUE;
		prev_config.input.colp_elep = IPIPE_GREEN_BLUE;
	} else {
		if (g_strcmp0 (colorptn, "BGbGrR") == 0) {
			prev_config.input.colp_olop = IPIPE_BLUE;
			prev_config.input.colp_olep = IPIPE_GREEN_BLUE;
			prev_config.input.colp_elop = IPIPE_GREEN_RED;
			prev_config.input.colp_elep = IPIPE_RED;
		} else {
			if (g_strcmp0 (colorptn, "RGrGbB") == 0) {
				prev_config.input.colp_olop = IPIPE_RED;
				prev_config.input.colp_olep = IPIPE_GREEN_RED;
				prev_config.input.colp_elop = IPIPE_GREEN_BLUE;
				prev_config.input.colp_elep = IPIPE_BLUE;
			} else {
				if (g_strcmp0 (colorptn, "GbBRGr") == 0) {
					prev_config.input.colp_olop = IPIPE_GREEN_BLUE;
					prev_config.input.colp_olep = IPIPE_BLUE;
					prev_config.input.colp_elop = IPIPE_RED;
					prev_config.input.colp_elep = IPIPE_GREEN_RED;
				} else {
					fprintf (stderr, "Ipiped: Invalid bayer pattern\n");
					result = FALSE;
					return result;
				}
			}
		}
	}
	ipiped_dm365_set_previewer_config (self, &chan_config);
	result = TRUE;
	return result;
}


static void ipiped_dm365_convertion_gains_from_q10 (Ipiped_dm365* self, guint32 gain, gint* decimal_gain, gint* integer_gain) {
	g_return_if_fail (self != NULL);
	*integer_gain = (gint) (gain >> 10);
	*decimal_gain = (gint) ((gain & 0x3ff) >> 1);
	return;
}


static void ipiped_dm365_convertion_gains_to_q10 (Ipiped_dm365* self, guint32* gain, gint decimal_gain, gint integer_gain) {
	g_return_if_fail (self != NULL);
	*gain = (guint32) (((decimal_gain & 0x3ff) << 1) | ((integer_gain & 0xf) << 10));
	return;
}


/**
     * Sets digital gain in the IPIPE, adjust a ratio gain of each color 
     * in the pattern(RGB) 
     * Each gain component can range from 0 to 15.998 in steps of 1/512
     * @param fd structure with file descriptors and owner flags
     * @param q10r_gain, in white balance module value for red component[0, 15.998]
     * @param q10g_gain, in white balance module value for green component[0, 15.998]
     * @param q10b_gain, in white balance module value for blue component[0, 15.998] 
     */
static gboolean ipiped_dm365_set_digital_gain_i (Ipiped_dm365* self, gint* previewer_fd, gchar* owner_previewer_fd, guint32 q10r_gain, guint32 q10g_gain, guint32 q10b_gain) {
	gboolean result = FALSE;
	struct prev_module_param mod_param = {0};
	struct prev_cap cap = {0};
	struct prev_wb wb = {0};
	gint gain_r_integer;
	gint gain_g_integer;
	gint gain_b_integer;
	gint gain_r_decimal;
	gint gain_g_decimal;
	gint gain_b_decimal;
	gint _tmp1_;
	gint _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	memset (&mod_param, 0, sizeof (struct prev_module_param));
	memset (&cap, 0, sizeof (struct prev_cap));
	memset (&wb, 0, sizeof (struct prev_wb));
	gain_r_integer = 0;
	gain_g_integer = 0;
	gain_b_integer = 0;
	gain_r_decimal = 0;
	gain_g_decimal = 0;
	gain_b_decimal = 0;
	if (q10r_gain > 0x3FFF) {
		q10r_gain = (guint32) 0x3FFF;
	}
	if (q10g_gain > 0x3FFF) {
		q10g_gain = (guint32) 0x3FFF;
	}
	if (q10b_gain > 0x3FFF) {
		q10b_gain = (guint32) 0x3FFF;
	}
	ipiped_dm365_convertion_gains_from_q10 (self, q10r_gain, &gain_r_decimal, &gain_r_integer);
	ipiped_dm365_convertion_gains_from_q10 (self, q10g_gain, &gain_g_decimal, &gain_g_integer);
	ipiped_dm365_convertion_gains_from_q10 (self, q10b_gain, &gain_b_decimal, &gain_b_integer);
	cap.index = (guint8) 0;
	if ((*previewer_fd) < 0) {
		gint _tmp0_;
		_tmp0_ = open ("/dev/davinci_previewer", O_RDWR, (mode_t) 0);
		*previewer_fd = _tmp0_;
		if ((*previewer_fd) < 0) {
			fprintf (stderr, "\n Failed to open dm365 previewer device file");
			result = FALSE;
			return result;
		}
		*owner_previewer_fd = (gchar) 0;
	}
	_tmp1_ = ioctl (*previewer_fd, PREV_ENUM_CAP, &cap);
	if (_tmp1_ < 0) {
		fprintf (stderr, "\n Failed to get previewer capabilities\n");
		result = FALSE;
		return result;
	}
	cap.module_id = PREV_WB;
	strcpy (mod_param.version, cap.version);
	mod_param.module_id = cap.module_id;
	wb.gain_r.integer = (gushort) gain_r_integer;
	wb.gain_r.decimal = (gushort) gain_r_decimal;
	wb.gain_gr.integer = (gushort) gain_g_integer;
	wb.gain_gr.decimal = (gushort) gain_g_decimal;
	wb.gain_gb.integer = (gushort) gain_g_integer;
	wb.gain_gb.decimal = (gushort) gain_g_decimal;
	wb.gain_b.integer = (gushort) gain_b_integer;
	wb.gain_b.decimal = (gushort) gain_b_decimal;
	wb.ofst_r = (gshort) 0;
	wb.ofst_gr = (gshort) 0;
	wb.ofst_gb = (gshort) 0;
	wb.ofst_b = (gshort) 0;
	mod_param.len = (guint8) sizeof (struct prev_wb);
	mod_param.param = &wb;
	_tmp2_ = ioctl (*previewer_fd, PREV_S_PARAM, &mod_param);
	if (_tmp2_ < 0) {
		fprintf (stderr, "Error setting params to the previewer\n");
		if ((*owner_previewer_fd) == 0) {
			close (*previewer_fd);
		}
		result = FALSE;
		return result;
	}
	if (abstc_video_processor_debug) {
		fprintf (stdout, "Set red gain to %f\n", (gdouble) (((gfloat) q10r_gain) / 1024));
		fprintf (stdout, "Set green gain to %f\n", (gdouble) (((gfloat) q10g_gain) / 1024));
		fprintf (stdout, "Set blue gain to %f\n", (gdouble) (((gfloat) q10b_gain) / 1024));
	}
	result = TRUE;
	return result;
}


/**
     * Sets digital gain
     */
gboolean ipiped_dm365_set_digital_gain (Ipiped_dm365* self, gdouble _red_gain, gdouble _green_gain, gdouble _blue_gain, GError** error) {
	gboolean result = FALSE;
	guint32 q10r_gain;
	guint32 q10g_gain;
	guint32 q10b_gain;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	q10r_gain = (guint32) ((_red_gain + (1 / 512)) * 1024);
	q10g_gain = (guint32) ((_green_gain + (1 / 512)) * 1024);
	q10b_gain = (guint32) ((_blue_gain + (1 / 512)) * 1024);
	_tmp0_ = ipiped_dm365_set_digital_gain_i (self, &((AbstcVideoProcessor*) self)->previewer_fd, &((AbstcVideoProcessor*) self)->owner_previewer_fd, q10r_gain, q10g_gain, q10b_gain);
	result = _tmp0_;
	return result;
}


/** Get the gain of each color component (RGB) of the white balance module. The 
     * returned gain values are on fixed-point Q10
     * Each gain component can range on float point from 0 to 15.998 in steps of 1/512
     * @param fd structure with file descriptors and owner flags
     * @param q10r_gain, in white balance module value for red component[0, 15.998]
     * @param q10g_gain, in white balance module value for green component[0, 15.998]
     * @param q10b_gain, in white balance module value for blue component[0, 15.998] 
     */
static gboolean ipiped_dm365_get_digital_gain_i (Ipiped_dm365* self, gint* previewer_fd, gchar* owner_previewer_fd, guint32* red_gain, guint32* green_gain, guint32* blue_gain) {
	gboolean result = FALSE;
	struct prev_module_param mod_param = {0};
	struct prev_wb wb = {0};
	struct prev_cap cap = {0};
	gint _tmp1_;
	gint _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	fprintf (stdout, "Digital gain\n");
	memset (&mod_param, 0, sizeof (struct prev_module_param));
	memset (&wb, 0, sizeof (struct prev_wb));
	memset (&cap, 0, sizeof (struct prev_cap));
	cap.index = (guint8) 0;
	if ((*previewer_fd) < 0) {
		gint _tmp0_;
		_tmp0_ = open ("/dev/davinci_previewer", O_RDWR, (mode_t) 0);
		*previewer_fd = _tmp0_;
		if ((*previewer_fd) < 0) {
			fprintf (stderr, "\n Failed to open dm365 previewer device file");
			result = FALSE;
			return result;
		}
		*owner_previewer_fd = (gchar) 0;
	}
	_tmp1_ = ioctl (*previewer_fd, PREV_ENUM_CAP, &cap);
	if (_tmp1_ < 0) {
		fprintf (stderr, "\n Failed to get previewer capabilities\n");
		result = FALSE;
		return result;
	}
	strcpy (mod_param.version, cap.version);
	mod_param.module_id = PREV_WB;
	mod_param.len = (guint8) sizeof (struct prev_wb);
	mod_param.param = &wb;
	_tmp2_ = ioctl (*previewer_fd, PREV_G_PARAM, &mod_param);
	if (_tmp2_ < 0) {
		fprintf (stderr, "Ipiped: Error in Setting params from driver\n");
		result = FALSE;
		return result;
	}
	ipiped_dm365_convertion_gains_to_q10 (self, red_gain, (gint) wb.gain_r.decimal, (gint) wb.gain_r.integer);
	ipiped_dm365_convertion_gains_to_q10 (self, green_gain, (gint) wb.gain_gr.decimal, (gint) wb.gain_gr.integer);
	ipiped_dm365_convertion_gains_to_q10 (self, blue_gain, (gint) wb.gain_b.decimal, (gint) wb.gain_b.integer);
	result = TRUE;
	return result;
}


/**
     * Gets digital gain
     */
gboolean ipiped_dm365_get_digital_gain (Ipiped_dm365* self, gdouble* _red_gain, gdouble* _green_gain, gdouble* _blue_gain, GError** error) {
	gdouble __red_gain = 0.0;
	gdouble __green_gain = 0.0;
	gdouble __blue_gain = 0.0;
	gboolean result = FALSE;
	guint32 q10red_gain;
	guint32 q10green_gain;
	guint32 q10blue_gain;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	q10red_gain = (guint32) 0;
	q10green_gain = (guint32) 0;
	q10blue_gain = (guint32) 0;
	_tmp0_ = ipiped_dm365_get_digital_gain_i (self, &((AbstcVideoProcessor*) self)->previewer_fd, &((AbstcVideoProcessor*) self)->owner_previewer_fd, &q10red_gain, &q10green_gain, &q10blue_gain);
	if (!_tmp0_) {
		fprintf (stderr, "Error:\n Failed to get the digital gain\n");
		result = FALSE;
		if (_red_gain) {
			*_red_gain = __red_gain;
		}
		if (_green_gain) {
			*_green_gain = __green_gain;
		}
		if (_blue_gain) {
			*_blue_gain = __blue_gain;
		}
		return result;
	} else {
		__red_gain = ((gdouble) q10red_gain) / 1024;
		__green_gain = ((gdouble) q10green_gain) / 1024;
		__blue_gain = ((gdouble) q10blue_gain) / 1024;
		result = TRUE;
		if (_red_gain) {
			*_red_gain = __red_gain;
		}
		if (_green_gain) {
			*_green_gain = __green_gain;
		}
		if (_blue_gain) {
			*_blue_gain = __blue_gain;
		}
		return result;
	}
	if (_red_gain) {
		*_red_gain = __red_gain;
	}
	if (_green_gain) {
		*_green_gain = __green_gain;
	}
	if (_blue_gain) {
		*_blue_gain = __blue_gain;
	}
}


/**
     * Sets luminance adjustment
     * Sets the values for the brightness and the contrast on the ipipe's 
     * luminance adjusment module.
     * @param bright brightness Offset value for brightness control(U8 = 0 - +255)
     * @param contr contrast(U4.4 = 0 - +15.94)
     */
gboolean ipiped_dm365_set_luminance_adj (Ipiped_dm365* self, gint bright, gdouble contr, GError** error) {
	gboolean result = FALSE;
	struct prev_module_param mod_param = {0};
	struct prev_lum_adj lum_adj = {0};
	struct prev_cap cap = {0};
	guint8 q4contr = 0U;
	gint _tmp0_;
	gint _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	memset (&mod_param, 0, sizeof (struct prev_module_param));
	memset (&lum_adj, 0, sizeof (struct prev_lum_adj));
	memset (&cap, 0, sizeof (struct prev_cap));
	cap.index = (guint8) 0;
	_tmp0_ = ioctl (((AbstcVideoProcessor*) self)->previewer_fd, PREV_ENUM_CAP, &cap);
	if (_tmp0_ < 0) {
		if (abstc_video_processor_debug) {
			fprintf (stderr, "Ipiped:Error in Setting cap from driver\n");
		}
		result = FALSE;
		return result;
	}
	cap.module_id = PREV_LUM_ADJ;
	strcpy (mod_param.version, cap.version);
	mod_param.module_id = cap.module_id;
	if (bright > 0xFF) {
		bright = 0xFF;
	}
	if (contr > 15.94) {
		contr = 15.94;
	}
	q4contr = (guint8) (contr * 16);
	lum_adj.brightness = (guint8) ((guchar) bright);
	lum_adj.contrast = (guint8) ((guchar) q4contr);
	mod_param.len = (guint8) sizeof (struct prev_lum_adj);
	mod_param.param = &lum_adj;
	_tmp1_ = ioctl (((AbstcVideoProcessor*) self)->previewer_fd, PREV_S_PARAM, &mod_param);
	if (_tmp1_ < 0) {
		if (abstc_video_processor_debug) {
			fprintf (stderr, "Ipiped:Error in Setting params from driver\n");
		}
		close (((AbstcVideoProcessor*) self)->previewer_fd);
		result = FALSE;
		return result;
	}
	if (abstc_video_processor_debug) {
		fprintf (stdout, "Set luminance adjustment to Brightness=%d," " Contrast=%f\n", bright, contr);
	}
	result = TRUE;
	return result;
}


/**
     * Gets luminance adjustment
     * Gets the values for the brightness and the contrast on the ipipe's 
     * luminance adjusment module
     */
gboolean ipiped_dm365_get_luminance_adj (Ipiped_dm365* self, gint* bright, gdouble* contr, GError** error) {
	gint _bright = 0;
	gdouble _contr = 0.0;
	gboolean result = FALSE;
	struct prev_module_param mod_param = {0};
	struct prev_lum_adj lum_adj = {0};
	struct prev_cap cap = {0};
	gint _tmp0_;
	gint _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	memset (&mod_param, 0, sizeof (struct prev_module_param));
	memset (&lum_adj, 0, sizeof (struct prev_lum_adj));
	memset (&cap, 0, sizeof (struct prev_cap));
	cap.index = (guint8) 0;
	_tmp0_ = ioctl (((AbstcVideoProcessor*) self)->previewer_fd, PREV_ENUM_CAP, &cap);
	if (_tmp0_ < 0) {
		if (abstc_video_processor_debug) {
			fprintf (stderr, "Ipiped:Error in Setting cap from driver\n");
		}
		result = FALSE;
		if (bright) {
			*bright = _bright;
		}
		if (contr) {
			*contr = _contr;
		}
		return result;
	}
	strcpy (mod_param.version, cap.version);
	mod_param.module_id = PREV_LUM_ADJ;
	mod_param.len = (guint8) sizeof (struct prev_lum_adj);
	mod_param.param = &lum_adj;
	_tmp1_ = ioctl (((AbstcVideoProcessor*) self)->previewer_fd, PREV_G_PARAM, &mod_param);
	if (_tmp1_ < 0) {
		if (abstc_video_processor_debug) {
			fprintf (stderr, "Ipiped:Error in Setting params from driver\n");
		}
		close (((AbstcVideoProcessor*) self)->previewer_fd);
		result = FALSE;
		if (bright) {
			*bright = _bright;
		}
		if (contr) {
			*contr = _contr;
		}
		return result;
	}
	_bright = (gint) lum_adj.brightness;
	_contr = ((gdouble) lum_adj.contrast) / 16;
	result = TRUE;
	if (bright) {
		*bright = _bright;
	}
	if (contr) {
		*contr = _contr;
	}
	return result;
}


static gboolean ipiped_dm365_real_get_video_processor_data (AbstcVideoProcessor* base, struct rraew_interface* interf) {
	Ipiped_dm365 * self;
	gboolean result = FALSE;
	self = (Ipiped_dm365*) base;
	*interf = dm365_vpfe_interface;
	result = TRUE;
	return result;
}


static void ipiped_dm365_class_init (Ipiped_dm365Class * klass) {
	ipiped_dm365_parent_class = g_type_class_peek_parent (klass);
	ABSTC_VIDEO_PROCESSOR_CLASS (klass)->get_video_processor_data = ipiped_dm365_real_get_video_processor_data;
	G_OBJECT_CLASS (klass)->finalize = ipiped_dm365_finalize;
}


static void ipiped_dm365_instance_init (Ipiped_dm365 * self) {
}


static void ipiped_dm365_finalize (GObject* obj) {
	Ipiped_dm365 * self;
	self = IPIPED_DM365 (obj);
	G_OBJECT_CLASS (ipiped_dm365_parent_class)->finalize (obj);
}


GType ipiped_dm365_get_type (void) {
	static volatile gsize ipiped_dm365_type_id__volatile = 0;
	if (g_once_init_enter (&ipiped_dm365_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (Ipiped_dm365Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ipiped_dm365_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Ipiped_dm365), 0, (GInstanceInitFunc) ipiped_dm365_instance_init, NULL };
		GType ipiped_dm365_type_id;
		ipiped_dm365_type_id = g_type_register_static (TYPE_ABSTC_VIDEO_PROCESSOR, "Ipiped_dm365", &g_define_type_info, 0);
		g_type_set_qdata (ipiped_dm365_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) ipiped_dm365_register_object);
		g_once_init_leave (&ipiped_dm365_type_id__volatile, ipiped_dm365_type_id);
	}
	return ipiped_dm365_type_id__volatile;
}


static void _dbus_ipiped_dm365_set_previewer_mode (Ipiped_dm365* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* mode_s = NULL;
	GVariant* _tmp11_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gboolean result;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp11_ = g_variant_iter_next_value (&_arguments_iter);
	mode_s = g_variant_dup_string (_tmp11_, NULL);
	g_variant_unref (_tmp11_);
	result = ipiped_dm365_set_previewer_mode (self, mode_s, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_boolean (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (mode_s);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipiped_dm365_set_color_pattern (Ipiped_dm365* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* colorptn = NULL;
	GVariant* _tmp12_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gboolean result;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp12_ = g_variant_iter_next_value (&_arguments_iter);
	colorptn = g_variant_dup_string (_tmp12_, NULL);
	g_variant_unref (_tmp12_);
	result = ipiped_dm365_set_color_pattern (self, colorptn, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_boolean (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (colorptn);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipiped_dm365_set_digital_gain (Ipiped_dm365* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gdouble _red_gain = 0.0;
	GVariant* _tmp13_;
	gdouble _green_gain = 0.0;
	GVariant* _tmp14_;
	gdouble _blue_gain = 0.0;
	GVariant* _tmp15_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gboolean result;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp13_ = g_variant_iter_next_value (&_arguments_iter);
	_red_gain = g_variant_get_double (_tmp13_);
	g_variant_unref (_tmp13_);
	_tmp14_ = g_variant_iter_next_value (&_arguments_iter);
	_green_gain = g_variant_get_double (_tmp14_);
	g_variant_unref (_tmp14_);
	_tmp15_ = g_variant_iter_next_value (&_arguments_iter);
	_blue_gain = g_variant_get_double (_tmp15_);
	g_variant_unref (_tmp15_);
	result = ipiped_dm365_set_digital_gain (self, _red_gain, _green_gain, _blue_gain, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_boolean (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipiped_dm365_get_digital_gain (Ipiped_dm365* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gdouble _red_gain = 0.0;
	gdouble _green_gain = 0.0;
	gdouble _blue_gain = 0.0;
	gboolean result;
	g_variant_iter_init (&_arguments_iter, parameters);
	result = ipiped_dm365_get_digital_gain (self, &_red_gain, &_green_gain, &_blue_gain, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_double (_red_gain));
	g_variant_builder_add_value (&_reply_builder, g_variant_new_double (_green_gain));
	g_variant_builder_add_value (&_reply_builder, g_variant_new_double (_blue_gain));
	g_variant_builder_add_value (&_reply_builder, g_variant_new_boolean (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipiped_dm365_set_luminance_adj (Ipiped_dm365* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gint bright = 0;
	GVariant* _tmp16_;
	gdouble contr = 0.0;
	GVariant* _tmp17_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gboolean result;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp16_ = g_variant_iter_next_value (&_arguments_iter);
	bright = g_variant_get_int32 (_tmp16_);
	g_variant_unref (_tmp16_);
	_tmp17_ = g_variant_iter_next_value (&_arguments_iter);
	contr = g_variant_get_double (_tmp17_);
	g_variant_unref (_tmp17_);
	result = ipiped_dm365_set_luminance_adj (self, bright, contr, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_boolean (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipiped_dm365_get_luminance_adj (Ipiped_dm365* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gint bright = 0;
	gdouble contr = 0.0;
	gboolean result;
	g_variant_iter_init (&_arguments_iter, parameters);
	result = ipiped_dm365_get_luminance_adj (self, &bright, &contr, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_int32 (bright));
	g_variant_builder_add_value (&_reply_builder, g_variant_new_double (contr));
	g_variant_builder_add_value (&_reply_builder, g_variant_new_boolean (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void ipiped_dm365_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "SetPreviewerMode") == 0) {
		_dbus_ipiped_dm365_set_previewer_mode (object, parameters, invocation);
	} else if (strcmp (method_name, "SetColorPattern") == 0) {
		_dbus_ipiped_dm365_set_color_pattern (object, parameters, invocation);
	} else if (strcmp (method_name, "SetDigitalGain") == 0) {
		_dbus_ipiped_dm365_set_digital_gain (object, parameters, invocation);
	} else if (strcmp (method_name, "GetDigitalGain") == 0) {
		_dbus_ipiped_dm365_get_digital_gain (object, parameters, invocation);
	} else if (strcmp (method_name, "SetLuminanceAdj") == 0) {
		_dbus_ipiped_dm365_set_luminance_adj (object, parameters, invocation);
	} else if (strcmp (method_name, "GetLuminanceAdj") == 0) {
		_dbus_ipiped_dm365_get_luminance_adj (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* ipiped_dm365_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean ipiped_dm365_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


guint ipiped_dm365_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_ipiped_dm365_dbus_interface_info), &_ipiped_dm365_dbus_interface_vtable, data, _ipiped_dm365_unregister_object, error);
	if (!result) {
		return 0;
	}
	return result;
}


static void _ipiped_dm365_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}



