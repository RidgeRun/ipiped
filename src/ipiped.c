/* ipiped.c generated by valac 0.12.0, the Vala compiler
 * generated from ipiped.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <rraew.h>
#include <stdio.h>


#define TYPE_IPIPE (ipipe_get_type ())
#define IPIPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IPIPE, Ipipe))
#define IPIPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IPIPE, IpipeClass))
#define IS_IPIPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IPIPE))
#define IS_IPIPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IPIPE))
#define IPIPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IPIPE, IpipeClass))

typedef struct _Ipipe Ipipe;
typedef struct _IpipeClass IpipeClass;
typedef struct _IpipePrivate IpipePrivate;

#define TYPE_ABSTC_VIDEO_PROCESSOR (abstc_video_processor_get_type ())
#define ABSTC_VIDEO_PROCESSOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ABSTC_VIDEO_PROCESSOR, AbstcVideoProcessor))
#define ABSTC_VIDEO_PROCESSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ABSTC_VIDEO_PROCESSOR, AbstcVideoProcessorClass))
#define IS_ABSTC_VIDEO_PROCESSOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ABSTC_VIDEO_PROCESSOR))
#define IS_ABSTC_VIDEO_PROCESSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ABSTC_VIDEO_PROCESSOR))
#define ABSTC_VIDEO_PROCESSOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ABSTC_VIDEO_PROCESSOR, AbstcVideoProcessorClass))

typedef struct _AbstcVideoProcessor AbstcVideoProcessor;
typedef struct _AbstcVideoProcessorClass AbstcVideoProcessorClass;

#define TYPE_ABSTC_SENSOR (abstc_sensor_get_type ())
#define ABSTC_SENSOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ABSTC_SENSOR, AbstcSensor))
#define ABSTC_SENSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ABSTC_SENSOR, AbstcSensorClass))
#define IS_ABSTC_SENSOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ABSTC_SENSOR))
#define IS_ABSTC_SENSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ABSTC_SENSOR))
#define ABSTC_SENSOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ABSTC_SENSOR, AbstcSensorClass))

typedef struct _AbstcSensor AbstcSensor;
typedef struct _AbstcSensorClass AbstcSensorClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _AbstcVideoProcessorPrivate AbstcVideoProcessorPrivate;
typedef struct _AbstcSensorPrivate AbstcSensorPrivate;

struct _Ipipe {
	GObject parent_instance;
	IpipePrivate * priv;
	AbstcVideoProcessor* video_processor_abstract;
	AbstcSensor* sensor_abstract;
};

struct _IpipeClass {
	GObjectClass parent_class;
};

struct _IpipePrivate {
	gchar* sensor;
	gchar* video_processor;
	GThread* thread;
	gboolean aew_running;
	gboolean clean_close;
	void* rraew;
	gint wait_time;
};

struct _AbstcVideoProcessor {
	GObject parent_instance;
	AbstcVideoProcessorPrivate * priv;
	gint previewer_fd;
	gint aew_fd;
	gchar owner_previewer_fd;
	gchar owner_aew_fd;
};

struct _AbstcVideoProcessorClass {
	GObjectClass parent_class;
	gboolean (*get_video_processor_data) (AbstcVideoProcessor* self, struct rraew_interface* interf);
};

struct _AbstcSensor {
	GObject parent_instance;
	AbstcSensorPrivate * priv;
	gint capture_fd;
	gchar owner_capture_fd;
};

struct _AbstcSensorClass {
	GObjectClass parent_class;
	gint (*get_sensor_data) (AbstcSensor* self, struct rraew_sensor* sensor);
};


static gpointer ipipe_parent_class = NULL;
static gboolean ipipe_debug;
static gboolean ipipe_debug = FALSE;
static gboolean ipipe_initialized;
static gboolean ipipe_initialized = FALSE;
extern gboolean abstc_video_processor_debug;
extern gboolean abstc_sensor_debug;

GType ipipe_get_type (void) G_GNUC_CONST;
guint ipipe_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType abstc_video_processor_get_type (void) G_GNUC_CONST;
GType abstc_sensor_get_type (void) G_GNUC_CONST;
#define IPIPE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_IPIPE, IpipePrivate))
enum  {
	IPIPE_DUMMY_PROPERTY
};
Ipipe* ipipe_new (const gchar* _sensor, const gchar* _video_processor, AbstcVideoProcessor* _video_processor_abstract, AbstcSensor* _sensor_abstract);
Ipipe* ipipe_construct (GType object_type, const gchar* _sensor, const gchar* _video_processor, AbstcVideoProcessor* _video_processor_abstract, AbstcSensor* _sensor_abstract);
void ipipe_enable_debug (Ipipe* self, gboolean enable, GError** error);
gboolean ipipe_ping (Ipipe* self, GError** error);
gchar* ipipe_get_sensor (Ipipe* self, GError** error);
gchar* ipipe_get_video_processor (Ipipe* self, GError** error);
static void* ipipe_aew_thread_func (Ipipe* self);
void ipipe_close_aew (Ipipe* self, GError** error);
gint ipipe_init_aew (Ipipe* self, const gchar* wb, const gchar* ae, const gchar* g, const gchar* meter, gint time, gint fps, gint segment_factor, gint width, gint height, gint center_percentage, GError** error);
gint abstc_sensor_get_sensor_data (AbstcSensor* self, struct rraew_sensor* sensor);
gboolean abstc_video_processor_get_video_processor_data (AbstcVideoProcessor* self, struct rraew_interface* interf);
static gpointer _ipipe_aew_thread_func_gthread_func (gpointer self);
static void ipipe_finalize (GObject* obj);
static void _dbus_ipipe_enable_debug (Ipipe* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipipe_ping (Ipipe* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipipe_get_sensor (Ipipe* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipipe_get_video_processor (Ipipe* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipipe_init_aew (Ipipe* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipipe_close_aew (Ipipe* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void ipipe_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* ipipe_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean ipipe_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _dbus_ipipe_error (GObject* _sender, const gchar* err_message, gpointer* _data);
static void _ipipe_unregister_object (gpointer user_data);

static const GDBusArgInfo _ipipe_dbus_arg_info_enable_debug_enable = {-1, "enable", "b"};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_enable_debug_in[] = {&_ipipe_dbus_arg_info_enable_debug_enable, NULL};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_enable_debug_out[] = {NULL};
static const GDBusMethodInfo _ipipe_dbus_method_info_enable_debug = {-1, "EnableDebug", (GDBusArgInfo **) (&_ipipe_dbus_arg_info_enable_debug_in), (GDBusArgInfo **) (&_ipipe_dbus_arg_info_enable_debug_out)};
static const GDBusArgInfo _ipipe_dbus_arg_info_ping_result = {-1, "result", "b"};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_ping_in[] = {NULL};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_ping_out[] = {&_ipipe_dbus_arg_info_ping_result, NULL};
static const GDBusMethodInfo _ipipe_dbus_method_info_ping = {-1, "Ping", (GDBusArgInfo **) (&_ipipe_dbus_arg_info_ping_in), (GDBusArgInfo **) (&_ipipe_dbus_arg_info_ping_out)};
static const GDBusArgInfo _ipipe_dbus_arg_info_get_sensor_result = {-1, "result", "s"};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_get_sensor_in[] = {NULL};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_get_sensor_out[] = {&_ipipe_dbus_arg_info_get_sensor_result, NULL};
static const GDBusMethodInfo _ipipe_dbus_method_info_get_sensor = {-1, "GetSensor", (GDBusArgInfo **) (&_ipipe_dbus_arg_info_get_sensor_in), (GDBusArgInfo **) (&_ipipe_dbus_arg_info_get_sensor_out)};
static const GDBusArgInfo _ipipe_dbus_arg_info_get_video_processor_result = {-1, "result", "s"};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_get_video_processor_in[] = {NULL};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_get_video_processor_out[] = {&_ipipe_dbus_arg_info_get_video_processor_result, NULL};
static const GDBusMethodInfo _ipipe_dbus_method_info_get_video_processor = {-1, "GetVideoProcessor", (GDBusArgInfo **) (&_ipipe_dbus_arg_info_get_video_processor_in), (GDBusArgInfo **) (&_ipipe_dbus_arg_info_get_video_processor_out)};
static const GDBusArgInfo _ipipe_dbus_arg_info_init_aew_wb = {-1, "wb", "s"};
static const GDBusArgInfo _ipipe_dbus_arg_info_init_aew_ae = {-1, "ae", "s"};
static const GDBusArgInfo _ipipe_dbus_arg_info_init_aew_g = {-1, "g", "s"};
static const GDBusArgInfo _ipipe_dbus_arg_info_init_aew_meter = {-1, "meter", "s"};
static const GDBusArgInfo _ipipe_dbus_arg_info_init_aew_time = {-1, "time", "i"};
static const GDBusArgInfo _ipipe_dbus_arg_info_init_aew_fps = {-1, "fps", "i"};
static const GDBusArgInfo _ipipe_dbus_arg_info_init_aew_segment_factor = {-1, "segment_factor", "i"};
static const GDBusArgInfo _ipipe_dbus_arg_info_init_aew_width = {-1, "width", "i"};
static const GDBusArgInfo _ipipe_dbus_arg_info_init_aew_height = {-1, "height", "i"};
static const GDBusArgInfo _ipipe_dbus_arg_info_init_aew_center_percentage = {-1, "center_percentage", "i"};
static const GDBusArgInfo _ipipe_dbus_arg_info_init_aew_result = {-1, "result", "i"};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_init_aew_in[] = {&_ipipe_dbus_arg_info_init_aew_wb, &_ipipe_dbus_arg_info_init_aew_ae, &_ipipe_dbus_arg_info_init_aew_g, &_ipipe_dbus_arg_info_init_aew_meter, &_ipipe_dbus_arg_info_init_aew_time, &_ipipe_dbus_arg_info_init_aew_fps, &_ipipe_dbus_arg_info_init_aew_segment_factor, &_ipipe_dbus_arg_info_init_aew_width, &_ipipe_dbus_arg_info_init_aew_height, &_ipipe_dbus_arg_info_init_aew_center_percentage, NULL};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_init_aew_out[] = {&_ipipe_dbus_arg_info_init_aew_result, NULL};
static const GDBusMethodInfo _ipipe_dbus_method_info_init_aew = {-1, "InitAew", (GDBusArgInfo **) (&_ipipe_dbus_arg_info_init_aew_in), (GDBusArgInfo **) (&_ipipe_dbus_arg_info_init_aew_out)};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_close_aew_in[] = {NULL};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_close_aew_out[] = {NULL};
static const GDBusMethodInfo _ipipe_dbus_method_info_close_aew = {-1, "CloseAew", (GDBusArgInfo **) (&_ipipe_dbus_arg_info_close_aew_in), (GDBusArgInfo **) (&_ipipe_dbus_arg_info_close_aew_out)};
static const GDBusMethodInfo * const _ipipe_dbus_method_info[] = {&_ipipe_dbus_method_info_enable_debug, &_ipipe_dbus_method_info_ping, &_ipipe_dbus_method_info_get_sensor, &_ipipe_dbus_method_info_get_video_processor, &_ipipe_dbus_method_info_init_aew, &_ipipe_dbus_method_info_close_aew, NULL};
static const GDBusArgInfo _ipipe_dbus_arg_info_error_err_message = {-1, "err_message", "s"};
static const GDBusArgInfo * const _ipipe_dbus_arg_info_error[] = {&_ipipe_dbus_arg_info_error_err_message, NULL};
static const GDBusSignalInfo _ipipe_dbus_signal_info_error = {-1, "Error", (GDBusArgInfo **) (&_ipipe_dbus_arg_info_error)};
static const GDBusSignalInfo * const _ipipe_dbus_signal_info[] = {&_ipipe_dbus_signal_info_error, NULL};
static const GDBusPropertyInfo * const _ipipe_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _ipipe_dbus_interface_info = {-1, "com.ridgerun.ipiped.IpipeInterface", (GDBusMethodInfo **) (&_ipipe_dbus_method_info), (GDBusSignalInfo **) (&_ipipe_dbus_signal_info), (GDBusPropertyInfo **) (&_ipipe_dbus_property_info)};
static const GDBusInterfaceVTable _ipipe_dbus_interface_vtable = {ipipe_dbus_interface_method_call, ipipe_dbus_interface_get_property, ipipe_dbus_interface_set_property};

/**
         * Create a new instance of a Ipipe daemon
         */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


Ipipe* ipipe_construct (GType object_type, const gchar* _sensor, const gchar* _video_processor, AbstcVideoProcessor* _video_processor_abstract, AbstcSensor* _sensor_abstract) {
	Ipipe * self = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	AbstcVideoProcessor* _tmp2_;
	AbstcSensor* _tmp3_;
	g_return_val_if_fail (_sensor != NULL, NULL);
	g_return_val_if_fail (_video_processor != NULL, NULL);
	g_return_val_if_fail (_video_processor_abstract != NULL, NULL);
	g_return_val_if_fail (_sensor_abstract != NULL, NULL);
	self = (Ipipe*) g_object_new (object_type, NULL);
	ipipe_initialized = FALSE;
	_tmp0_ = g_strdup (_sensor);
	_g_free0 (self->priv->sensor);
	self->priv->sensor = _tmp0_;
	_tmp1_ = g_strdup (_video_processor);
	_g_free0 (self->priv->video_processor);
	self->priv->video_processor = _tmp1_;
	_tmp2_ = _g_object_ref0 (_video_processor_abstract);
	_g_object_unref0 (self->video_processor_abstract);
	self->video_processor_abstract = _tmp2_;
	_tmp3_ = _g_object_ref0 (_sensor_abstract);
	_g_object_unref0 (self->sensor_abstract);
	self->sensor_abstract = _tmp3_;
	ipipe_debug = FALSE;
	return self;
}


Ipipe* ipipe_new (const gchar* _sensor, const gchar* _video_processor, AbstcVideoProcessor* _video_processor_abstract, AbstcSensor* _sensor_abstract) {
	return ipipe_construct (TYPE_IPIPE, _sensor, _video_processor, _video_processor_abstract, _sensor_abstract);
}


/**
         * Debug
         * Enable/Disable the debug information in all the functions
         * @param enable if true print debug information  
         */
void ipipe_enable_debug (Ipipe* self, gboolean enable, GError** error) {
	g_return_if_fail (self != NULL);
	ipipe_debug = enable;
	abstc_video_processor_debug = TRUE;
	abstc_sensor_debug = TRUE;
}


/**
         * Ping
         * Show to the ipipe-client that an instance of the ipiped daemon is 
         * alive
         */
gboolean ipipe_ping (Ipipe* self, GError** error) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


gchar* ipipe_get_sensor (Ipipe* self, GError** error) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self->priv->sensor);
	result = _tmp0_;
	return result;
}


gchar* ipipe_get_video_processor (Ipipe* self, GError** error) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self->priv->video_processor);
	result = _tmp0_;
	return result;
}


static void* ipipe_aew_thread_func (Ipipe* self) {
	void* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	while (TRUE) {
		gint _tmp0_;
		if (!self->priv->aew_running) {
			break;
		}
		g_usleep ((gulong) self->priv->wait_time);
		_tmp0_ = run_rraew (self->priv->rraew);
		if (_tmp0_ < 0) {
			self->priv->clean_close = FALSE;
			ipipe_close_aew (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_IO_ERROR) {
					goto __catch1_g_io_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	goto __finally1;
	__catch1_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Fail to execute:%s\n", e->message);
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = NULL;
	return result;
}


/**
         * AEW Algorithm initialization
         * Uses the parameters given by the user to configure the aew library, 
         * sets the functions to access the sensor and the dm365 interface 
         * (vpfe ipipe). Creates an aew structure and a thread for the aew loop
         * @param wb string that chooses the auto white balance algorithm, 
         * can be "G" for gray world or "W" for white balance  or "N" to do not 
         * apply an auto white balance.
         * @param ae string that chooses the auto exposure algorithm, can be 
         * "EC" for electronic centric or "N" to do not apply an auto exposure.
         * @param g string that chooses the gain type, can be "S" for sensor 
         * gain or "D" for digital gain.
         * @param meter string that chooses the metering system for the auto 
         * exposure algorithm, can be "S" for spot or "P" for partial or "C" for 
         * electronic centric or "SG" for segmented image or "A" for average.
         * @param time it is the time between aew algorithms iterations
         * @param fps is the minimum allowed frame rate
         * @param segment_factor a percentage of the maximun image divisions 
         */
static gpointer _ipipe_aew_thread_func_gthread_func (gpointer self) {
	gpointer result;
	result = ipipe_aew_thread_func (self);
	return result;
}


gint ipipe_init_aew (Ipipe* self, const gchar* wb, const gchar* ae, const gchar* g, const gchar* meter, gint time, gint fps, gint segment_factor, gint width, gint height, gint center_percentage, GError** error) {
	gint result = 0;
	struct rraew_file_descriptors fd = {0};
	enum rraew_white_balance_algo wb_algo = 0;
	enum rraew_exposure_algo ae_algo = 0;
	enum rraew_gain_type gain_type = 0;
	enum rraew_metering_type meter_type = 0;
	struct rraew_sensor sensor = {0};
	struct rraew_interface interf = {0};
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	void* _tmp2_ = NULL;
	gboolean _tmp3_;
	GThread* _tmp4_ = NULL;
	GThread* _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (wb != NULL, 0);
	g_return_val_if_fail (ae != NULL, 0);
	g_return_val_if_fail (g != NULL, 0);
	g_return_val_if_fail (meter != NULL, 0);
	memset (&fd, 0, sizeof (struct rraew_file_descriptors));
	self->priv->wait_time = time;
	memset (&sensor, 0, sizeof (struct rraew_sensor));
	memset (&interf, 0, sizeof (struct rraew_interface));
	if (self->priv->aew_running) {
		fprintf (stderr, "%s", "The AEW algorithm is alreadty being " "executed. Please finish the current session\n by using " "close-aew. Then you will be able to start a new one\n");
		result = -1;
		return result;
	}
	if (time > 1000000) {
		fprintf (stderr, "\nIpiped:Wait time is greater than the maximum\n");
		result = -1;
		return result;
	}
	if (segment_factor > 100) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = segment_factor < 1;
	}
	if (_tmp0_) {
		fprintf (stderr, "\nIpiped:Segmentation factor must be between 1 and 100\n");
		result = -1;
		return result;
	}
	if (g_strcmp0 (g, "S") == 0) {
		gain_type = GAIN_SENSOR;
	} else {
		if (g_strcmp0 (g, "D") == 0) {
			gain_type = GAIN_DIGITAL;
		} else {
			fprintf (stderr, "\nIpiped:Invalid gain type\n");
			result = -1;
			return result;
		}
	}
	if (g_strcmp0 (ae, "EC") == 0) {
		ae_algo = AE_EC;
	} else {
		if (g_strcmp0 (ae, "N") == 0) {
			ae_algo = AE_NONE;
		} else {
			fprintf (stderr, "\nIpiped:Invalid auto exposure algorithm\n");
			result = -1;
			return result;
		}
	}
	if (g_strcmp0 (wb, "W") == 0) {
		wb_algo = AWB_WHITE_PATCH;
	} else {
		if (g_strcmp0 (wb, "W2") == 0) {
			wb_algo = AWB_WHITE_PATCH_2;
		} else {
			if (g_strcmp0 (wb, "G") == 0) {
				wb_algo = AWB_GRAY_WORLD;
			} else {
				if (g_strcmp0 (wb, "N") == 0) {
					wb_algo = AWB_NONE;
				} else {
					fprintf (stderr, "\nIpiped:Invalid white-balance algorithm\n");
					result = -1;
					return result;
				}
			}
		}
	}
	if (g_strcmp0 (meter, "P") == 0) {
		meter_type = METER_PARTIAL_AREA;
	} else {
		if (g_strcmp0 (meter, "C") == 0) {
			meter_type = METER_CENTER_WEIGHTED;
		} else {
			if (g_strcmp0 (meter, "A") == 0) {
				meter_type = METER_AVERAGE;
			} else {
				if (g_strcmp0 (meter, "SG") == 0) {
					meter_type = METER_SEGMENT;
				} else {
					fprintf (stderr, "\nIpiped:Invalid metering type\n");
					result = -1;
					return result;
				}
			}
		}
	}
	abstc_sensor_get_sensor_data (self->sensor_abstract, &sensor);
	_tmp1_ = abstc_video_processor_get_video_processor_data (self->video_processor_abstract, &interf);
	if (!_tmp1_) {
		fprintf (stderr, "Can't get video processor data\n");
		result = -1;
		return result;
	}
	fd.previewer_fd = self->video_processor_abstract->previewer_fd;
	fd.owner_previewer_fd = self->video_processor_abstract->owner_previewer_fd;
	fd.aew_fd = self->video_processor_abstract->aew_fd;
	fd.owner_aew_fd = self->video_processor_abstract->owner_aew_fd;
	fd.capture_fd = self->sensor_abstract->capture_fd;
	fd.owner_capture_fd = self->sensor_abstract->owner_capture_fd;
	_tmp2_ = create_rraew (wb_algo, ae_algo, meter_type, width, height, fps, segment_factor, center_percentage, gain_type, &fd, &sensor, &interf);
	self->priv->rraew = _tmp2_;
	self->priv->aew_running = TRUE;
	self->priv->clean_close = TRUE;
	_tmp3_ = g_thread_supported ();
	if (!_tmp3_) {
		g_error ("ipiped.vala:220: Cannot run without thread support");
	}
	_tmp4_ = g_thread_create (_ipipe_aew_thread_func_gthread_func, self, TRUE, &_inner_error_);
	_tmp5_ = _tmp4_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_THREAD_ERROR) {
			goto __catch2_g_thread_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	self->priv->thread = _tmp5_;
	goto __finally2;
	__catch2_g_thread_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		result = -1;
		_g_error_free0 (e);
		return result;
	}
	__finally2:
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			return 0;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
	}
	result = 0;
	return result;
}


/**
         * End AEW Algorithm, disable AEW engine
         */
void ipipe_close_aew (Ipipe* self, GError** error) {
	g_return_if_fail (self != NULL);
	self->priv->aew_running = FALSE;
	if (self->priv->clean_close) {
		g_thread_join (self->priv->thread);
		self->priv->clean_close = FALSE;
	}
	if (self->priv->rraew != NULL) {
		destroy_rraew (self->priv->rraew);
		self->priv->rraew = NULL;
	}
}


static void ipipe_class_init (IpipeClass * klass) {
	ipipe_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (IpipePrivate));
	G_OBJECT_CLASS (klass)->finalize = ipipe_finalize;
	g_signal_new ("error", TYPE_IPIPE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
}


static void ipipe_instance_init (Ipipe * self) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	self->priv = IPIPE_GET_PRIVATE (self);
	_tmp0_ = g_strdup ("");
	self->priv->sensor = _tmp0_;
	_tmp1_ = g_strdup ("");
	self->priv->video_processor = _tmp1_;
	self->priv->aew_running = FALSE;
	self->priv->clean_close = FALSE;
	self->priv->rraew = NULL;
	self->priv->wait_time = 0;
}


static void ipipe_finalize (GObject* obj) {
	Ipipe * self;
	self = IPIPE (obj);
	_g_free0 (self->priv->sensor);
	_g_free0 (self->priv->video_processor);
	_g_object_unref0 (self->video_processor_abstract);
	_g_object_unref0 (self->sensor_abstract);
	G_OBJECT_CLASS (ipipe_parent_class)->finalize (obj);
}


/**
 * ipiped/src/ipiped.vala
 *
 * Ipipe class - framework for controlling and configuring ipipe using D-Bus messages
 *
 * Copyright(c) 2010, RidgeRun
 * All rights reserved.
*/
GType ipipe_get_type (void) {
	static volatile gsize ipipe_type_id__volatile = 0;
	if (g_once_init_enter (&ipipe_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IpipeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ipipe_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Ipipe), 0, (GInstanceInitFunc) ipipe_instance_init, NULL };
		GType ipipe_type_id;
		ipipe_type_id = g_type_register_static (G_TYPE_OBJECT, "Ipipe", &g_define_type_info, 0);
		g_type_set_qdata (ipipe_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) ipipe_register_object);
		g_once_init_leave (&ipipe_type_id__volatile, ipipe_type_id);
	}
	return ipipe_type_id__volatile;
}


static void _dbus_ipipe_enable_debug (Ipipe* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gboolean enable = FALSE;
	GVariant* _tmp0_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp0_ = g_variant_iter_next_value (&_arguments_iter);
	enable = g_variant_get_boolean (_tmp0_);
	g_variant_unref (_tmp0_);
	ipipe_enable_debug (self, enable, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipipe_ping (Ipipe* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gboolean result;
	g_variant_iter_init (&_arguments_iter, parameters);
	result = ipipe_ping (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_boolean (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipipe_get_sensor (Ipipe* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gchar* result;
	g_variant_iter_init (&_arguments_iter, parameters);
	result = ipipe_get_sensor (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_string (result));
	_g_free0 ( result);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipipe_get_video_processor (Ipipe* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gchar* result;
	g_variant_iter_init (&_arguments_iter, parameters);
	result = ipipe_get_video_processor (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_string (result));
	_g_free0 ( result);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipipe_init_aew (Ipipe* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* wb = NULL;
	GVariant* _tmp1_;
	gchar* ae = NULL;
	GVariant* _tmp2_;
	gchar* g = NULL;
	GVariant* _tmp3_;
	gchar* meter = NULL;
	GVariant* _tmp4_;
	gint time = 0;
	GVariant* _tmp5_;
	gint fps = 0;
	GVariant* _tmp6_;
	gint segment_factor = 0;
	GVariant* _tmp7_;
	gint width = 0;
	GVariant* _tmp8_;
	gint height = 0;
	GVariant* _tmp9_;
	gint center_percentage = 0;
	GVariant* _tmp10_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gint result;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp1_ = g_variant_iter_next_value (&_arguments_iter);
	wb = g_variant_dup_string (_tmp1_, NULL);
	g_variant_unref (_tmp1_);
	_tmp2_ = g_variant_iter_next_value (&_arguments_iter);
	ae = g_variant_dup_string (_tmp2_, NULL);
	g_variant_unref (_tmp2_);
	_tmp3_ = g_variant_iter_next_value (&_arguments_iter);
	g = g_variant_dup_string (_tmp3_, NULL);
	g_variant_unref (_tmp3_);
	_tmp4_ = g_variant_iter_next_value (&_arguments_iter);
	meter = g_variant_dup_string (_tmp4_, NULL);
	g_variant_unref (_tmp4_);
	_tmp5_ = g_variant_iter_next_value (&_arguments_iter);
	time = g_variant_get_int32 (_tmp5_);
	g_variant_unref (_tmp5_);
	_tmp6_ = g_variant_iter_next_value (&_arguments_iter);
	fps = g_variant_get_int32 (_tmp6_);
	g_variant_unref (_tmp6_);
	_tmp7_ = g_variant_iter_next_value (&_arguments_iter);
	segment_factor = g_variant_get_int32 (_tmp7_);
	g_variant_unref (_tmp7_);
	_tmp8_ = g_variant_iter_next_value (&_arguments_iter);
	width = g_variant_get_int32 (_tmp8_);
	g_variant_unref (_tmp8_);
	_tmp9_ = g_variant_iter_next_value (&_arguments_iter);
	height = g_variant_get_int32 (_tmp9_);
	g_variant_unref (_tmp9_);
	_tmp10_ = g_variant_iter_next_value (&_arguments_iter);
	center_percentage = g_variant_get_int32 (_tmp10_);
	g_variant_unref (_tmp10_);
	result = ipipe_init_aew (self, wb, ae, g, meter, time, fps, segment_factor, width, height, center_percentage, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_int32 (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (wb);
	_g_free0 (ae);
	_g_free0 (g);
	_g_free0 (meter);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipipe_close_aew (Ipipe* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	ipipe_close_aew (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void ipipe_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "EnableDebug") == 0) {
		_dbus_ipipe_enable_debug (object, parameters, invocation);
	} else if (strcmp (method_name, "Ping") == 0) {
		_dbus_ipipe_ping (object, parameters, invocation);
	} else if (strcmp (method_name, "GetSensor") == 0) {
		_dbus_ipipe_get_sensor (object, parameters, invocation);
	} else if (strcmp (method_name, "GetVideoProcessor") == 0) {
		_dbus_ipipe_get_video_processor (object, parameters, invocation);
	} else if (strcmp (method_name, "InitAew") == 0) {
		_dbus_ipipe_init_aew (object, parameters, invocation);
	} else if (strcmp (method_name, "CloseAew") == 0) {
		_dbus_ipipe_close_aew (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* ipipe_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean ipipe_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


static void _dbus_ipipe_error (GObject* _sender, const gchar* err_message, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (err_message));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "com.ridgerun.ipiped.IpipeInterface", "Error", _arguments, NULL);
}


guint ipipe_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_ipipe_dbus_interface_info), &_ipipe_dbus_interface_vtable, data, _ipipe_unregister_object, error);
	if (!result) {
		return 0;
	}
	g_signal_connect (object, "error", (GCallback) _dbus_ipipe_error, data);
	return result;
}


static void _ipipe_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}



