/* AbstcSensor.c generated by valac 0.12.0, the Vala compiler
 * generated from AbstcSensor.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <rraew.h>


#define TYPE_ABSTC_SENSOR (abstc_sensor_get_type ())
#define ABSTC_SENSOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ABSTC_SENSOR, AbstcSensor))
#define ABSTC_SENSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ABSTC_SENSOR, AbstcSensorClass))
#define IS_ABSTC_SENSOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ABSTC_SENSOR))
#define IS_ABSTC_SENSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ABSTC_SENSOR))
#define ABSTC_SENSOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ABSTC_SENSOR, AbstcSensorClass))

typedef struct _AbstcSensor AbstcSensor;
typedef struct _AbstcSensorClass AbstcSensorClass;
typedef struct _AbstcSensorPrivate AbstcSensorPrivate;

struct _AbstcSensor {
	GObject parent_instance;
	AbstcSensorPrivate * priv;
	gint capture_fd;
	gchar owner_capture_fd;
};

struct _AbstcSensorClass {
	GObjectClass parent_class;
	gint (*get_sensor_data) (AbstcSensor* self, struct rraew_sensor* sensor);
};


static gpointer abstc_sensor_parent_class = NULL;
extern gboolean abstc_sensor_debug;
gboolean abstc_sensor_debug = FALSE;

GType abstc_sensor_get_type (void) G_GNUC_CONST;
enum  {
	ABSTC_SENSOR_DUMMY_PROPERTY
};
gint abstc_sensor_get_sensor_data (AbstcSensor* self, struct rraew_sensor* sensor);
static gint abstc_sensor_real_get_sensor_data (AbstcSensor* self, struct rraew_sensor* sensor);
AbstcSensor* abstc_sensor_construct (GType object_type);
static void abstc_sensor_finalize (GObject* obj);


static gint abstc_sensor_real_get_sensor_data (AbstcSensor* self, struct rraew_sensor* sensor) {
	g_return_val_if_fail (self != NULL, 0);
	g_critical ("Type `%s' does not implement abstract method `abstc_sensor_get_sensor_data'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return 0;
}


gint abstc_sensor_get_sensor_data (AbstcSensor* self, struct rraew_sensor* sensor) {
	return ABSTC_SENSOR_GET_CLASS (self)->get_sensor_data (self, sensor);
}


AbstcSensor* abstc_sensor_construct (GType object_type) {
	AbstcSensor * self = NULL;
	self = (AbstcSensor*) g_object_new (object_type, NULL);
	return self;
}


static void abstc_sensor_class_init (AbstcSensorClass * klass) {
	abstc_sensor_parent_class = g_type_class_peek_parent (klass);
	ABSTC_SENSOR_CLASS (klass)->get_sensor_data = abstc_sensor_real_get_sensor_data;
	G_OBJECT_CLASS (klass)->finalize = abstc_sensor_finalize;
}


static void abstc_sensor_instance_init (AbstcSensor * self) {
}


static void abstc_sensor_finalize (GObject* obj) {
	AbstcSensor * self;
	self = ABSTC_SENSOR (obj);
	G_OBJECT_CLASS (abstc_sensor_parent_class)->finalize (obj);
}


GType abstc_sensor_get_type (void) {
	static volatile gsize abstc_sensor_type_id__volatile = 0;
	if (g_once_init_enter (&abstc_sensor_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AbstcSensorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) abstc_sensor_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AbstcSensor), 0, (GInstanceInitFunc) abstc_sensor_instance_init, NULL };
		GType abstc_sensor_type_id;
		abstc_sensor_type_id = g_type_register_static (G_TYPE_OBJECT, "AbstcSensor", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&abstc_sensor_type_id__volatile, abstc_sensor_type_id);
	}
	return abstc_sensor_type_id__volatile;
}



