/* main.c generated by valac 0.11.5, the Vala compiler
 * generated from main.vala, do not modify */

/*
 * ipiped/src/main.vala
 *
 * Main function for Ipipe daemon - controlling IPIPE path on the Video Processing Subsystem
 *
 * Copyright (c) 2010, RidgeRun
 * All rights reserved.
 *
 * GPL2 license - See http://www.opensource.org/licenses/gpl-2.0.php for complete text.
*/
/*Global Variable*/

#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


#define TYPE_ABSTC_VIDEO_PROCESSOR (abstc_video_processor_get_type ())
#define ABSTC_VIDEO_PROCESSOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ABSTC_VIDEO_PROCESSOR, AbstcVideoProcessor))
#define ABSTC_VIDEO_PROCESSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ABSTC_VIDEO_PROCESSOR, AbstcVideoProcessorClass))
#define IS_ABSTC_VIDEO_PROCESSOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ABSTC_VIDEO_PROCESSOR))
#define IS_ABSTC_VIDEO_PROCESSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ABSTC_VIDEO_PROCESSOR))
#define ABSTC_VIDEO_PROCESSOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ABSTC_VIDEO_PROCESSOR, AbstcVideoProcessorClass))

typedef struct _AbstcVideoProcessor AbstcVideoProcessor;
typedef struct _AbstcVideoProcessorClass AbstcVideoProcessorClass;

#define TYPE_ABSTC_SENSOR (abstc_sensor_get_type ())
#define ABSTC_SENSOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ABSTC_SENSOR, AbstcSensor))
#define ABSTC_SENSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ABSTC_SENSOR, AbstcSensorClass))
#define IS_ABSTC_SENSOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ABSTC_SENSOR))
#define IS_ABSTC_SENSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ABSTC_SENSOR))
#define ABSTC_SENSOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ABSTC_SENSOR, AbstcSensorClass))

typedef struct _AbstcSensor AbstcSensor;
typedef struct _AbstcSensorClass AbstcSensorClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_IPIPED_DM365 (ipiped_dm365_get_type ())
#define IPIPED_DM365(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IPIPED_DM365, Ipiped_dm365))
#define IPIPED_DM365_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IPIPED_DM365, Ipiped_dm365Class))
#define IS_IPIPED_DM365(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IPIPED_DM365))
#define IS_IPIPED_DM365_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IPIPED_DM365))
#define IPIPED_DM365_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IPIPED_DM365, Ipiped_dm365Class))

typedef struct _Ipiped_dm365 Ipiped_dm365;
typedef struct _Ipiped_dm365Class Ipiped_dm365Class;

#define TYPE_IPIPED_MT9P031 (ipiped_mt9p031_get_type ())
#define IPIPED_MT9P031(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IPIPED_MT9P031, Ipiped_mt9p031))
#define IPIPED_MT9P031_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IPIPED_MT9P031, Ipiped_mt9p031Class))
#define IS_IPIPED_MT9P031(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IPIPED_MT9P031))
#define IS_IPIPED_MT9P031_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IPIPED_MT9P031))
#define IPIPED_MT9P031_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IPIPED_MT9P031, Ipiped_mt9p031Class))

typedef struct _Ipiped_mt9p031 Ipiped_mt9p031;
typedef struct _Ipiped_mt9p031Class Ipiped_mt9p031Class;

#define TYPE_IPIPE (ipipe_get_type ())
#define IPIPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IPIPE, Ipipe))
#define IPIPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IPIPE, IpipeClass))
#define IS_IPIPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IPIPE))
#define IS_IPIPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IPIPE))
#define IPIPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IPIPE, IpipeClass))

typedef struct _Ipipe Ipipe;
typedef struct _IpipeClass IpipeClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))



void on_bus_aquired (GDBusConnection* conn);
GType abstc_video_processor_get_type (void) G_GNUC_CONST;
GType abstc_sensor_get_type (void) G_GNUC_CONST;
Ipiped_dm365* ipiped_dm365_new (void);
Ipiped_dm365* ipiped_dm365_construct (GType object_type);
GType ipiped_dm365_get_type (void) G_GNUC_CONST;
guint ipiped_dm365_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
Ipiped_mt9p031* ipiped_mt9p031_new (void);
Ipiped_mt9p031* ipiped_mt9p031_construct (GType object_type);
GType ipiped_mt9p031_get_type (void) G_GNUC_CONST;
guint ipiped_mt9p031_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
Ipipe* ipipe_new (const gchar* _sensor, const gchar* _video_processor, AbstcVideoProcessor* _video_processor_abstract, AbstcSensor* _sensor_abstract);
Ipipe* ipipe_construct (GType object_type, const gchar* _sensor, const gchar* _video_processor, AbstcVideoProcessor* _video_processor_abstract, AbstcSensor* _sensor_abstract);
GType ipipe_get_type (void) G_GNUC_CONST;
guint ipipe_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
void _vala_main (gchar** args, int args_length1);
static void _on_bus_aquired_gbus_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self);
static void _lambda0_ (void);
static void __lambda0__gbus_name_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self);
static void _lambda1_ (void);
static void __lambda1__gbus_name_lost_callback (GDBusConnection* connection, const gchar* name, gpointer self);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void on_bus_aquired (GDBusConnection* conn) {
	gchar* data = NULL;
	gchar* _tmp0_;
	gchar* filename;
	gchar* _tmp1_;
	gchar* video_processor;
	gchar* _tmp2_;
	gchar* sensor;
	AbstcVideoProcessor* video_processor_abstract = NULL;
	AbstcSensor* sensor_abstract = NULL;
	FILE* _tmp3_ = NULL;
	FILE* file;
	Ipipe* _tmp19_ = NULL;
	Ipipe* ipipe;
	GError * _inner_error_ = NULL;
	g_return_if_fail (conn != NULL);
	_tmp0_ = g_strdup ("/usr/etc/ipiped.conf");
	filename = _tmp0_;
	_tmp1_ = g_strdup ("");
	video_processor = _tmp1_;
	_tmp2_ = g_strdup ("");
	sensor = _tmp2_;
	_tmp3_ = fopen (filename, "r");
	file = _tmp3_;
	if (file != NULL) {
		gchar line[128] = {0};
		while (TRUE) {
			const gchar* _tmp4_ = NULL;
			gchar* _tmp5_;
			gchar* _tmp6_;
			gchar** _tmp7_;
			gchar** _tmp8_ = NULL;
			gchar** s;
			gint s_length1;
			gint _s_size_;
			_tmp4_ = fgets (line, 128, file);
			_tmp5_ = g_strdup (_tmp4_);
			_tmp6_ = _tmp5_;
			_g_free0 (data);
			data = _tmp6_;
			if (!(data != NULL)) {
				break;
			}
			_tmp8_ = _tmp7_ = g_strsplit (data, "=", 2);
			s = _tmp8_;
			s_length1 = _vala_array_length (_tmp7_);
			_s_size_ = _vala_array_length (_tmp7_);
			if (g_strcmp0 (s[0], "processor") == 0) {
				gchar* _tmp9_ = NULL;
				gchar* _tmp10_;
				_tmp9_ = string_strip (s[1]);
				_tmp10_ = _tmp9_;
				_g_free0 (video_processor);
				video_processor = _tmp10_;
			} else {
				if (g_strcmp0 (s[0], "sensor") == 0) {
					gchar* _tmp11_ = NULL;
					gchar* _tmp12_;
					_tmp11_ = string_strip (s[1]);
					_tmp12_ = _tmp11_;
					_g_free0 (sensor);
					sensor = _tmp12_;
				}
			}
			s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
		}
	} else {
		fprintf (stderr, "Configuration file %s doesn't exist\n", filename);
		_fclose0 (file);
		_g_object_unref0 (sensor_abstract);
		_g_object_unref0 (video_processor_abstract);
		_g_free0 (sensor);
		_g_free0 (video_processor);
		_g_free0 (filename);
		_g_free0 (data);
		return;
	}
	if (g_strcmp0 (video_processor, "dm365") == 0) {
		Ipiped_dm365* _tmp13_ = NULL;
		Ipiped_dm365* ipiped_dm365;
		AbstcVideoProcessor* _tmp14_;
		AbstcVideoProcessor* _tmp15_;
		_tmp13_ = ipiped_dm365_new ();
		ipiped_dm365 = _tmp13_;
		_tmp14_ = _g_object_ref0 ((AbstcVideoProcessor*) ipiped_dm365);
		_tmp15_ = _tmp14_;
		_g_object_unref0 (video_processor_abstract);
		video_processor_abstract = _tmp15_;
		ipiped_dm365_register_object (ipiped_dm365, conn, "/com/ridgerun/ipiped/ipipe", &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (ipiped_dm365);
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch0_g_io_error;
			}
			_g_object_unref0 (ipiped_dm365);
			_fclose0 (file);
			_g_object_unref0 (sensor_abstract);
			_g_object_unref0 (video_processor_abstract);
			_g_free0 (sensor);
			_g_free0 (video_processor);
			_g_free0 (filename);
			_g_free0 (data);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_object_unref0 (ipiped_dm365);
	} else {
		fprintf (stderr, "Video processor doesn't match with available platforms \n");
		_fclose0 (file);
		_g_object_unref0 (sensor_abstract);
		_g_object_unref0 (video_processor_abstract);
		_g_free0 (sensor);
		_g_free0 (video_processor);
		_g_free0 (filename);
		_g_free0 (data);
		return;
	}
	if (g_strcmp0 (sensor, "mt9p031") == 0) {
		Ipiped_mt9p031* _tmp16_ = NULL;
		Ipiped_mt9p031* ipiped_mt9p031;
		AbstcSensor* _tmp17_;
		AbstcSensor* _tmp18_;
		_tmp16_ = ipiped_mt9p031_new ();
		ipiped_mt9p031 = _tmp16_;
		_tmp17_ = _g_object_ref0 ((AbstcSensor*) ipiped_mt9p031);
		_tmp18_ = _tmp17_;
		_g_object_unref0 (sensor_abstract);
		sensor_abstract = _tmp18_;
		ipiped_mt9p031_register_object (ipiped_mt9p031, conn, "/com/ridgerun/ipiped/ipipe", &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (ipiped_mt9p031);
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch0_g_io_error;
			}
			_g_object_unref0 (ipiped_mt9p031);
			_fclose0 (file);
			_g_object_unref0 (sensor_abstract);
			_g_object_unref0 (video_processor_abstract);
			_g_free0 (sensor);
			_g_free0 (video_processor);
			_g_free0 (filename);
			_g_free0 (data);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_object_unref0 (ipiped_mt9p031);
	} else {
		fprintf (stderr, "Sensor support doesn't exist \n");
		_fclose0 (file);
		_g_object_unref0 (sensor_abstract);
		_g_object_unref0 (video_processor_abstract);
		_g_free0 (sensor);
		_g_free0 (video_processor);
		_g_free0 (filename);
		_g_free0 (data);
		return;
	}
	_tmp19_ = ipipe_new (sensor, video_processor, video_processor_abstract, sensor_abstract);
	ipipe = _tmp19_;
	ipipe_register_object (ipipe, conn, "/com/ridgerun/ipiped/ipipe", &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (ipipe);
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch0_g_io_error;
		}
		_g_object_unref0 (ipipe);
		_fclose0 (file);
		_g_object_unref0 (sensor_abstract);
		_g_object_unref0 (video_processor_abstract);
		_g_free0 (sensor);
		_g_free0 (video_processor);
		_g_free0 (filename);
		_g_free0 (data);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (ipipe);
	goto __finally0;
	__catch0_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Could not register service\n");
		fprintf (stderr, "Ipiped: Error: %s\n", e->message);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_fclose0 (file);
		_g_object_unref0 (sensor_abstract);
		_g_object_unref0 (video_processor_abstract);
		_g_free0 (sensor);
		_g_free0 (video_processor);
		_g_free0 (filename);
		_g_free0 (data);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_fclose0 (file);
	_g_object_unref0 (sensor_abstract);
	_g_object_unref0 (video_processor_abstract);
	_g_free0 (sensor);
	_g_free0 (video_processor);
	_g_free0 (filename);
	_g_free0 (data);
}


static void _on_bus_aquired_gbus_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	on_bus_aquired (connection);
}


static void _lambda0_ (void) {
}


static void __lambda0__gbus_name_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	_lambda0_ ();
}


static void _lambda1_ (void) {
	fprintf (stderr, "%s", "Ipiped: Failed to obtain primary ownership of " "the service\nThis usually means there is another instance of " " ipiped already running\n");
}


static void __lambda1__gbus_name_lost_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	_lambda1_ ();
}


void _vala_main (gchar** args, int args_length1) {
	GMainLoop* _tmp0_ = NULL;
	GMainLoop* _tmp1_;
	g_bus_own_name_with_closures (G_BUS_TYPE_SYSTEM, "com.ridgerun.ipiped", G_BUS_NAME_OWNER_FLAGS_NONE, (GClosure*) ((_on_bus_aquired_gbus_acquired_callback == NULL) ? NULL : g_cclosure_new ((GCallback) _on_bus_aquired_gbus_acquired_callback, NULL, NULL)), (GClosure*) ((__lambda0__gbus_name_acquired_callback == NULL) ? NULL : g_cclosure_new ((GCallback) __lambda0__gbus_name_acquired_callback, NULL, NULL)), (GClosure*) ((__lambda1__gbus_name_lost_callback == NULL) ? NULL : g_cclosure_new ((GCallback) __lambda1__gbus_name_lost_callback, NULL, NULL)));
	_tmp0_ = g_main_loop_new (NULL, FALSE);
	_tmp1_ = _tmp0_;
	g_main_loop_run (_tmp1_);
	_g_main_loop_unref0 (_tmp1_);
}


int main (int argc, char ** argv) {
	g_thread_init (NULL);
	g_type_init ();
	_vala_main (argv, argc);
	return 0;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



