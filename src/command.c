/* command.c generated by valac 0.11.5, the Vala compiler
 * generated from command.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


#define TYPE_IPIPE_COMMAND (ipipe_command_get_type ())
#define IPIPE_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IPIPE_COMMAND, IpipeCommand))
#define IPIPE_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IPIPE_COMMAND, IpipeCommandClass))
#define IS_IPIPE_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IPIPE_COMMAND))
#define IS_IPIPE_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IPIPE_COMMAND))
#define IPIPE_COMMAND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IPIPE_COMMAND, IpipeCommandClass))

typedef struct _IpipeCommand IpipeCommand;
typedef struct _IpipeCommandClass IpipeCommandClass;
typedef struct _IpipeCommandPrivate IpipeCommandPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_COMMAND_MANAGER (command_manager_get_type ())
#define COMMAND_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMMAND_MANAGER, CommandManager))
#define COMMAND_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMMAND_MANAGER, CommandManagerClass))
#define IS_COMMAND_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMMAND_MANAGER))
#define IS_COMMAND_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMMAND_MANAGER))
#define COMMAND_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMMAND_MANAGER, CommandManagerClass))

typedef struct _CommandManager CommandManager;
typedef struct _CommandManagerClass CommandManagerClass;
typedef struct _CommandManagerPrivate CommandManagerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

typedef gint (*IpipeCommandCmdFunc) (gchar** s, int s_length1, void* user_data);
struct _IpipeCommand {
	GObject parent_instance;
	IpipeCommandPrivate * priv;
	gchar* name;
	IpipeCommandCmdFunc cmd_func;
	gpointer cmd_func_target;
	GDestroyNotify cmd_func_target_destroy_notify;
	gchar* usage;
	gchar* doc;
	gchar* args;
};

struct _IpipeCommandClass {
	GObjectClass parent_class;
};

struct _CommandManager {
	GObject parent_instance;
	CommandManagerPrivate * priv;
};

struct _CommandManagerClass {
	GObjectClass parent_class;
};

struct _CommandManagerPrivate {
	IpipeCommand** CmdMap;
	gint CmdMap_length1;
	gint _CmdMap_size_;
};


static gpointer ipipe_command_parent_class = NULL;
static gpointer command_manager_parent_class = NULL;

GType ipipe_command_get_type (void) G_GNUC_CONST;
enum  {
	IPIPE_COMMAND_DUMMY_PROPERTY
};
IpipeCommand* ipipe_command_new (const gchar* _name, IpipeCommandCmdFunc _cmd, void* _cmd_target, const gchar* _usage, const gchar* _doc, const gchar* _args);
IpipeCommand* ipipe_command_construct (GType object_type, const gchar* _name, IpipeCommandCmdFunc _cmd, void* _cmd_target, const gchar* _usage, const gchar* _doc, const gchar* _args);
IpipeCommand* ipipe_command_new_empty (void);
IpipeCommand* ipipe_command_construct_empty (GType object_type);
static void ipipe_command_finalize (GObject* obj);
GType command_manager_get_type (void) G_GNUC_CONST;
#define COMMAND_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_COMMAND_MANAGER, CommandManagerPrivate))
enum  {
	COMMAND_MANAGER_DUMMY_PROPERTY
};
CommandManager* command_manager_new (void);
CommandManager* command_manager_construct (GType object_type);
void command_manager_new_command (CommandManager* self, const gchar* _name, IpipeCommandCmdFunc _cmdfunc, void* _cmdfunc_target, const gchar* _usage, const gchar* _doc, const gchar* _args);
static void _vala_array_add1 (IpipeCommand*** array, int* length, int* size, IpipeCommand* value);
IpipeCommand* command_manager_find_command (CommandManager* self, const gchar* name);
gint command_manager_execute_cmd (CommandManager* self, gchar** args, int args_length1);
gint command_manager_command_help (CommandManager* self, gchar** args, int args_length1);
static void command_manager_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


/** Command constructor. Creates an object for a specific command
     * @param _name string of the command name 
     * @param _cmd function that has to be call for the command
     * @param _usage syntax required in order to execute the command in the 
     * command line
     * @param _doc description of the command funcionality
     * @param _args explanation of the function's arguments
     */
IpipeCommand* ipipe_command_construct (GType object_type, const gchar* _name, IpipeCommandCmdFunc _cmd, void* _cmd_target, const gchar* _usage, const gchar* _doc, const gchar* _args) {
	IpipeCommand * self = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	IpipeCommandCmdFunc _tmp2_;
	IpipeCommandCmdFunc _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	g_return_val_if_fail (_name != NULL, NULL);
	g_return_val_if_fail (_usage != NULL, NULL);
	g_return_val_if_fail (_doc != NULL, NULL);
	g_return_val_if_fail (_args != NULL, NULL);
	self = (IpipeCommand*) g_object_new (object_type, NULL);
	_tmp0_ = g_strdup (_name);
	_tmp1_ = _tmp0_;
	_g_free0 (self->name);
	self->name = _tmp1_;
	_tmp2_ = _cmd;
	_tmp3_ = _tmp2_;
	(self->cmd_func_target_destroy_notify == NULL) ? NULL : (self->cmd_func_target_destroy_notify (self->cmd_func_target), NULL);
	self->cmd_func = NULL;
	self->cmd_func_target = NULL;
	self->cmd_func_target_destroy_notify = NULL;
	self->cmd_func_target = _cmd_target;
	self->cmd_func_target_destroy_notify = NULL;
	self->cmd_func = _tmp3_;
	_tmp4_ = g_strdup (_usage);
	_tmp5_ = _tmp4_;
	_g_free0 (self->usage);
	self->usage = _tmp5_;
	_tmp6_ = g_strdup (_doc);
	_tmp7_ = _tmp6_;
	_g_free0 (self->doc);
	self->doc = _tmp7_;
	_tmp8_ = g_strdup (_args);
	_tmp9_ = _tmp8_;
	_g_free0 (self->args);
	self->args = _tmp9_;
	return self;
}


IpipeCommand* ipipe_command_new (const gchar* _name, IpipeCommandCmdFunc _cmd, void* _cmd_target, const gchar* _usage, const gchar* _doc, const gchar* _args) {
	return ipipe_command_construct (TYPE_IPIPE_COMMAND, _name, _cmd, _cmd_target, _usage, _doc, _args);
}


IpipeCommand* ipipe_command_construct_empty (GType object_type) {
	IpipeCommand * self = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	IpipeCommandCmdFunc _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	self = (IpipeCommand*) g_object_new (object_type, NULL);
	_tmp0_ = g_strdup ("");
	_tmp1_ = _tmp0_;
	_g_free0 (self->name);
	self->name = _tmp1_;
	_tmp2_ = NULL;
	(self->cmd_func_target_destroy_notify == NULL) ? NULL : (self->cmd_func_target_destroy_notify (self->cmd_func_target), NULL);
	self->cmd_func = NULL;
	self->cmd_func_target = NULL;
	self->cmd_func_target_destroy_notify = NULL;
	self->cmd_func_target = NULL;
	self->cmd_func_target_destroy_notify = NULL;
	self->cmd_func = _tmp2_;
	_tmp3_ = g_strdup ("");
	_tmp4_ = _tmp3_;
	_g_free0 (self->usage);
	self->usage = _tmp4_;
	_tmp5_ = g_strdup ("");
	_tmp6_ = _tmp5_;
	_g_free0 (self->doc);
	self->doc = _tmp6_;
	_tmp7_ = g_strdup ("");
	_tmp8_ = _tmp7_;
	_g_free0 (self->args);
	self->args = _tmp8_;
	return self;
}


IpipeCommand* ipipe_command_new_empty (void) {
	return ipipe_command_construct_empty (TYPE_IPIPE_COMMAND);
}


static void ipipe_command_class_init (IpipeCommandClass * klass) {
	ipipe_command_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = ipipe_command_finalize;
}


static void ipipe_command_instance_init (IpipeCommand * self) {
}


static void ipipe_command_finalize (GObject* obj) {
	IpipeCommand * self;
	self = IPIPE_COMMAND (obj);
	_g_free0 (self->name);
	(self->cmd_func_target_destroy_notify == NULL) ? NULL : (self->cmd_func_target_destroy_notify (self->cmd_func_target), NULL);
	self->cmd_func = NULL;
	self->cmd_func_target = NULL;
	self->cmd_func_target_destroy_notify = NULL;
	_g_free0 (self->usage);
	_g_free0 (self->doc);
	_g_free0 (self->args);
	G_OBJECT_CLASS (ipipe_command_parent_class)->finalize (obj);
}


/**
 * Command
 * This class is a template for a command information. It includes the command 
 * name, the function that has to be executed and the explanation of the 
 * command syntax, function arguments and command description
 */
GType ipipe_command_get_type (void) {
	static volatile gsize ipipe_command_type_id__volatile = 0;
	if (g_once_init_enter (&ipipe_command_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IpipeCommandClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ipipe_command_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IpipeCommand), 0, (GInstanceInitFunc) ipipe_command_instance_init, NULL };
		GType ipipe_command_type_id;
		ipipe_command_type_id = g_type_register_static (G_TYPE_OBJECT, "IpipeCommand", &g_define_type_info, 0);
		g_once_init_leave (&ipipe_command_type_id__volatile, ipipe_command_type_id);
	}
	return ipipe_command_type_id__volatile;
}


/** Command constructor. Creates an object for a specific command
     * @param _name string of the command name 
     * @param _cmd function that has to be call for the command
     * @param _usage syntax required in order to execute the command in the 
     * command line
     * @param _doc description of the command funcionality
     * @param _args explanation of the function's arguments
     */
CommandManager* command_manager_construct (GType object_type) {
	CommandManager * self = NULL;
	self = (CommandManager*) g_object_new (object_type, NULL);
	return self;
}


CommandManager* command_manager_new (void) {
	return command_manager_construct (TYPE_COMMAND_MANAGER);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _vala_array_add1 (IpipeCommand*** array, int* length, int* size, IpipeCommand* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (IpipeCommand*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


void command_manager_new_command (CommandManager* self, const gchar* _name, IpipeCommandCmdFunc _cmdfunc, void* _cmdfunc_target, const gchar* _usage, const gchar* _doc, const gchar* _args) {
	IpipeCommand* _tmp0_ = NULL;
	IpipeCommand* new_cmd;
	IpipeCommand* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (_name != NULL);
	g_return_if_fail (_usage != NULL);
	g_return_if_fail (_doc != NULL);
	g_return_if_fail (_args != NULL);
	_tmp0_ = ipipe_command_new (_name, _cmdfunc, _cmdfunc_target, _usage, _doc, _args);
	new_cmd = _tmp0_;
	_tmp1_ = _g_object_ref0 (new_cmd);
	_vala_array_add1 (&self->priv->CmdMap, &self->priv->CmdMap_length1, &self->priv->_CmdMap_size_, _tmp1_);
	_g_object_unref0 (new_cmd);
	return;
}


/**
     * Look up 'name' as the name of a command, and returns in 'cmd' 
     * the CmdMap instances that matches with the given name.
     * Return non-zero if name isn't a command name. */
IpipeCommand* command_manager_find_command (CommandManager* self, const gchar* name) {
	IpipeCommand* result = NULL;
	gint ind = 0;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	{
		gboolean _tmp0_;
		ind = 0;
		_tmp0_ = TRUE;
		while (TRUE) {
			gint _tmp1_;
			if (!_tmp0_) {
				ind++;
			}
			_tmp0_ = FALSE;
			if (!(ind < self->priv->CmdMap_length1)) {
				break;
			}
			_tmp1_ = g_strcmp0 (name, self->priv->CmdMap[ind]->name);
			if (_tmp1_ == 0) {
				IpipeCommand* _tmp2_;
				_tmp2_ = _g_object_ref0 (self->priv->CmdMap[ind]);
				result = _tmp2_;
				return result;
			}
		}
	}
	result = NULL;
	return result;
}


gint command_manager_execute_cmd (CommandManager* self, gchar** args, int args_length1) {
	gint result = 0;
	IpipeCommand* _tmp0_ = NULL;
	IpipeCommand* Cmd;
	IpipeCommand* _tmp1_ = NULL;
	IpipeCommand* _tmp2_;
	gint _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = ipipe_command_new_empty ();
	Cmd = _tmp0_;
	_tmp1_ = command_manager_find_command (self, args[0]);
	_tmp2_ = _tmp1_;
	_g_object_unref0 (Cmd);
	Cmd = _tmp2_;
	if (Cmd == NULL) {
		fprintf (stdout, "%s: No such command for IpipeClient.\n", args[0]);
		result = 1;
		_g_object_unref0 (Cmd);
		return result;
	}
	_tmp3_ = Cmd->cmd_func ((gchar**) args, args_length1, Cmd->cmd_func_target);
	result = _tmp3_;
	_g_object_unref0 (Cmd);
	return result;
}


gint command_manager_command_help (CommandManager* self, gchar** args, int args_length1) {
	gint result = 0;
	gint ind = 0;
	gint printed;
	g_return_val_if_fail (self != NULL, 0);
	printed = 0;
	{
		gboolean _tmp0_;
		ind = 0;
		_tmp0_ = TRUE;
		while (TRUE) {
			if (!_tmp0_) {
				ind++;
			}
			_tmp0_ = FALSE;
			if (!(ind < self->priv->CmdMap_length1)) {
				break;
			}
			if (args[1] == NULL) {
				gint _tmp1_;
				if (printed == 0) {
					fprintf (stdout, "%s", "Request the syntax of an specific command with " "\"help <command>\".\n" "This is the list of supported commands:\n" "\nCOMMANDS supported:\n\nCommand\t\t\t\tDescription\n\n");
				}
				_tmp1_ = strlen (self->priv->CmdMap[ind]->name);
				if (_tmp1_ < 8) {
					fprintf (stdout, "%s\t\t\t%s.\n", self->priv->CmdMap[ind]->name, self->priv->CmdMap[ind]->doc);
				} else {
					gint _tmp2_;
					_tmp2_ = strlen (self->priv->CmdMap[ind]->name);
					if (_tmp2_ < 16) {
						fprintf (stdout, "%s\t\t%s.\n", self->priv->CmdMap[ind]->name, self->priv->CmdMap[ind]->doc);
					} else {
						fprintf (stdout, "%s\t%s.\n", self->priv->CmdMap[ind]->name, self->priv->CmdMap[ind]->doc);
					}
				}
				printed++;
			} else {
				gint _tmp3_;
				_tmp3_ = g_strcmp0 (args[1], self->priv->CmdMap[ind]->name);
				if (_tmp3_ == 0) {
					fprintf (stdout, "\nCommand: %s\n", self->priv->CmdMap[ind]->name);
					fprintf (stdout, "Syntax: %s\n", self->priv->CmdMap[ind]->usage);
					fprintf (stdout, "Description: %s\n", self->priv->CmdMap[ind]->doc);
					if (g_strcmp0 (self->priv->CmdMap[ind]->args, "") != 0) {
						fprintf (stdout, "Arguments: %s\n", self->priv->CmdMap[ind]->args);
					}
					printed++;
					break;
				}
			}
		}
	}
	fprintf (stdout, "\n");
	if (printed == 0) {
		fprintf (stdout, "No commands match with '%s'.  Possible commands are:\n\n", args[1]);
		{
			gboolean _tmp4_;
			ind = 0;
			_tmp4_ = TRUE;
			while (TRUE) {
				if (!_tmp4_) {
					ind++;
				}
				_tmp4_ = FALSE;
				if (!(ind < self->priv->CmdMap_length1)) {
					break;
				}
				fprintf (stdout, "-%s\n", self->priv->CmdMap[ind]->name);
			}
		}
		result = -1;
		return result;
	}
	result = 0;
	return result;
}


static void command_manager_class_init (CommandManagerClass * klass) {
	command_manager_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (CommandManagerPrivate));
	G_OBJECT_CLASS (klass)->finalize = command_manager_finalize;
}


static void command_manager_instance_init (CommandManager * self) {
	IpipeCommand** _tmp0_ = NULL;
	self->priv = COMMAND_MANAGER_GET_PRIVATE (self);
	_tmp0_ = g_new0 (IpipeCommand*, 0 + 1);
	self->priv->CmdMap = _tmp0_;
	self->priv->CmdMap_length1 = 0;
	self->priv->_CmdMap_size_ = self->priv->CmdMap_length1;
}


static void command_manager_finalize (GObject* obj) {
	CommandManager * self;
	self = COMMAND_MANAGER (obj);
	self->priv->CmdMap = (_vala_array_free (self->priv->CmdMap, self->priv->CmdMap_length1, (GDestroyNotify) g_object_unref), NULL);
	G_OBJECT_CLASS (command_manager_parent_class)->finalize (obj);
}


/**
 * CommandManage
 * This class is a template for a command management information. It include 
 * an array of Command and functions to manipulate them. It is capable of 
 * create and add new commands, find a especific command, execute command's 
 * functions and display the help information.
 */
GType command_manager_get_type (void) {
	static volatile gsize command_manager_type_id__volatile = 0;
	if (g_once_init_enter (&command_manager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CommandManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) command_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CommandManager), 0, (GInstanceInitFunc) command_manager_instance_init, NULL };
		GType command_manager_type_id;
		command_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "CommandManager", &g_define_type_info, 0);
		g_once_init_leave (&command_manager_type_id__volatile, command_manager_type_id);
	}
	return command_manager_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



