/* ipiped-mt9p031.c generated by valac 0.11.5, the Vala compiler
 * generated from ipiped-mt9p031.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <rraew.h>
#include <fcntl.h>
#include <sys/types.h>
#include <string.h>
#include <linux/videodev2.h>
#include <stropts.h>
#include <stdio.h>
#include <float.h>
#include <math.h>
#include <gio/gio.h>


#define TYPE_ABSTC_SENSOR (abstc_sensor_get_type ())
#define ABSTC_SENSOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ABSTC_SENSOR, AbstcSensor))
#define ABSTC_SENSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ABSTC_SENSOR, AbstcSensorClass))
#define IS_ABSTC_SENSOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ABSTC_SENSOR))
#define IS_ABSTC_SENSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ABSTC_SENSOR))
#define ABSTC_SENSOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ABSTC_SENSOR, AbstcSensorClass))

typedef struct _AbstcSensor AbstcSensor;
typedef struct _AbstcSensorClass AbstcSensorClass;
typedef struct _AbstcSensorPrivate AbstcSensorPrivate;

#define TYPE_IPIPED_MT9P031 (ipiped_mt9p031_get_type ())
#define IPIPED_MT9P031(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IPIPED_MT9P031, Ipiped_mt9p031))
#define IPIPED_MT9P031_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IPIPED_MT9P031, Ipiped_mt9p031Class))
#define IS_IPIPED_MT9P031(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IPIPED_MT9P031))
#define IS_IPIPED_MT9P031_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IPIPED_MT9P031))
#define IPIPED_MT9P031_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IPIPED_MT9P031, Ipiped_mt9p031Class))

typedef struct _Ipiped_mt9p031 Ipiped_mt9p031;
typedef struct _Ipiped_mt9p031Class Ipiped_mt9p031Class;
typedef struct _Ipiped_mt9p031Private Ipiped_mt9p031Private;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _AbstcSensor {
	GObject parent_instance;
	AbstcSensorPrivate * priv;
	gint capture_fd;
	gchar owner_capture_fd;
};

struct _AbstcSensorClass {
	GObjectClass parent_class;
	gint (*get_sensor_data) (AbstcSensor* self, struct rraew_sensor* sensor);
};

struct _Ipiped_mt9p031 {
	AbstcSensor parent_instance;
	Ipiped_mt9p031Private * priv;
};

struct _Ipiped_mt9p031Class {
	AbstcSensorClass parent_class;
};


static gpointer ipiped_mt9p031_parent_class = NULL;
extern gboolean abstc_sensor_debug;

GType abstc_sensor_get_type (void) G_GNUC_CONST;
GType ipiped_mt9p031_get_type (void) G_GNUC_CONST;
guint ipiped_mt9p031_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
enum  {
	IPIPED_MT9P031_DUMMY_PROPERTY
};
Ipiped_mt9p031* ipiped_mt9p031_new (void);
Ipiped_mt9p031* ipiped_mt9p031_construct (GType object_type);
AbstcSensor* abstc_sensor_construct (GType object_type);
static gint ipiped_mt9p031_open_sensor (Ipiped_mt9p031* self);
static gint ipiped_mt9p031_set_sensor_gain_i (Ipiped_mt9p031* self, gint* capture_fd, gchar* owner_capture_fd, guint32 q10r_gain, guint32 q10g_gain, guint32 q10b_gain);
gint ipiped_mt9p031_set_sensor_gain (Ipiped_mt9p031* self, gdouble r_gain, gdouble g_gain, gdouble b_gain, GError** error);
static gint ipiped_mt9p031_get_sensor_gain_i (Ipiped_mt9p031* self, gint* capture_fd, gchar* owner_capture_fd, guint32* q10r_gain, guint32* q10g_gain, guint32* q10b_gain);
gint ipiped_mt9p031_get_sensor_gain (Ipiped_mt9p031* self, GError** error);
gint ipiped_mt9p031_sensor_flip_vertically (Ipiped_mt9p031* self, const gchar* state, GError** error);
gint ipiped_mt9p031_sensor_flip_horizontally (Ipiped_mt9p031* self, const gchar* state, GError** error);
static gint ipiped_mt9p031_set_exposure_time_i (Ipiped_mt9p031* self, gint* capture_fd, gchar* owner_capture_fd, guint32 exp_time);
gint ipiped_mt9p031_set_exposure_time (Ipiped_mt9p031* self, gint _exp_time, GError** error);
static gint ipiped_mt9p031_get_exposure_time_i (Ipiped_mt9p031* self, gint* capture_fd, gchar* owner_capture_fd, guint32* exp);
gint ipiped_mt9p031_get_exposure_time (Ipiped_mt9p031* self, GError** error);
static gint ipiped_mt9p031_get_vertical_flip (Ipiped_mt9p031* self, gint* vf);
static gint ipiped_mt9p031_get_horizontal_flip (Ipiped_mt9p031* self, gint* hf);
static gboolean ipiped_mt9p031_get_color_pattern (Ipiped_mt9p031* self, struct colorpattern* color_pattern);
static gint ipiped_mt9p031_real_get_sensor_data (AbstcSensor* base, struct rraew_sensor* sensor);
static gint _ipiped_mt9p031_set_sensor_gain_i_set_gain (gint* fd, gchar* owner_fd, guint32 r_gain, guint32 g_gain, guint32 b_gain, gpointer self);
static gint _ipiped_mt9p031_get_sensor_gain_i_get_gain (gint* fd, gchar* owner_fd, guint32* r_gain, guint32* g_gain, guint32* b_gain, gpointer self);
static gint _ipiped_mt9p031_set_exposure_time_i_set_exposure (gint* capture_fd, gchar* owner_capture_fd, guint32 exp_time, gpointer self);
static gint _ipiped_mt9p031_get_exposure_time_i_get_exposure (gint* capture_fd, gchar* owner_capture_fd, guint32* exp_time, gpointer self);
static void _dbus_ipiped_mt9p031_set_sensor_gain (Ipiped_mt9p031* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipiped_mt9p031_get_sensor_gain (Ipiped_mt9p031* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipiped_mt9p031_sensor_flip_vertically (Ipiped_mt9p031* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipiped_mt9p031_sensor_flip_horizontally (Ipiped_mt9p031* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipiped_mt9p031_set_exposure_time (Ipiped_mt9p031* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_ipiped_mt9p031_get_exposure_time (Ipiped_mt9p031* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void ipiped_mt9p031_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* ipiped_mt9p031_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean ipiped_mt9p031_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _ipiped_mt9p031_unregister_object (gpointer user_data);

static const GDBusArgInfo _ipiped_mt9p031_dbus_arg_info_set_sensor_gain_r_gain = {-1, "r_gain", "d"};
static const GDBusArgInfo _ipiped_mt9p031_dbus_arg_info_set_sensor_gain_g_gain = {-1, "g_gain", "d"};
static const GDBusArgInfo _ipiped_mt9p031_dbus_arg_info_set_sensor_gain_b_gain = {-1, "b_gain", "d"};
static const GDBusArgInfo _ipiped_mt9p031_dbus_arg_info_set_sensor_gain_result = {-1, "result", "i"};
static const GDBusArgInfo * const _ipiped_mt9p031_dbus_arg_info_set_sensor_gain_in[] = {&_ipiped_mt9p031_dbus_arg_info_set_sensor_gain_r_gain, &_ipiped_mt9p031_dbus_arg_info_set_sensor_gain_g_gain, &_ipiped_mt9p031_dbus_arg_info_set_sensor_gain_b_gain, NULL};
static const GDBusArgInfo * const _ipiped_mt9p031_dbus_arg_info_set_sensor_gain_out[] = {&_ipiped_mt9p031_dbus_arg_info_set_sensor_gain_result, NULL};
static const GDBusMethodInfo _ipiped_mt9p031_dbus_method_info_set_sensor_gain = {-1, "SetSensorGain", (GDBusArgInfo **) (&_ipiped_mt9p031_dbus_arg_info_set_sensor_gain_in), (GDBusArgInfo **) (&_ipiped_mt9p031_dbus_arg_info_set_sensor_gain_out)};
static const GDBusArgInfo _ipiped_mt9p031_dbus_arg_info_get_sensor_gain_result = {-1, "result", "i"};
static const GDBusArgInfo * const _ipiped_mt9p031_dbus_arg_info_get_sensor_gain_in[] = {NULL};
static const GDBusArgInfo * const _ipiped_mt9p031_dbus_arg_info_get_sensor_gain_out[] = {&_ipiped_mt9p031_dbus_arg_info_get_sensor_gain_result, NULL};
static const GDBusMethodInfo _ipiped_mt9p031_dbus_method_info_get_sensor_gain = {-1, "GetSensorGain", (GDBusArgInfo **) (&_ipiped_mt9p031_dbus_arg_info_get_sensor_gain_in), (GDBusArgInfo **) (&_ipiped_mt9p031_dbus_arg_info_get_sensor_gain_out)};
static const GDBusArgInfo _ipiped_mt9p031_dbus_arg_info_sensor_flip_vertically_state = {-1, "state", "s"};
static const GDBusArgInfo _ipiped_mt9p031_dbus_arg_info_sensor_flip_vertically_result = {-1, "result", "i"};
static const GDBusArgInfo * const _ipiped_mt9p031_dbus_arg_info_sensor_flip_vertically_in[] = {&_ipiped_mt9p031_dbus_arg_info_sensor_flip_vertically_state, NULL};
static const GDBusArgInfo * const _ipiped_mt9p031_dbus_arg_info_sensor_flip_vertically_out[] = {&_ipiped_mt9p031_dbus_arg_info_sensor_flip_vertically_result, NULL};
static const GDBusMethodInfo _ipiped_mt9p031_dbus_method_info_sensor_flip_vertically = {-1, "SensorFlipVertically", (GDBusArgInfo **) (&_ipiped_mt9p031_dbus_arg_info_sensor_flip_vertically_in), (GDBusArgInfo **) (&_ipiped_mt9p031_dbus_arg_info_sensor_flip_vertically_out)};
static const GDBusArgInfo _ipiped_mt9p031_dbus_arg_info_sensor_flip_horizontally_state = {-1, "state", "s"};
static const GDBusArgInfo _ipiped_mt9p031_dbus_arg_info_sensor_flip_horizontally_result = {-1, "result", "i"};
static const GDBusArgInfo * const _ipiped_mt9p031_dbus_arg_info_sensor_flip_horizontally_in[] = {&_ipiped_mt9p031_dbus_arg_info_sensor_flip_horizontally_state, NULL};
static const GDBusArgInfo * const _ipiped_mt9p031_dbus_arg_info_sensor_flip_horizontally_out[] = {&_ipiped_mt9p031_dbus_arg_info_sensor_flip_horizontally_result, NULL};
static const GDBusMethodInfo _ipiped_mt9p031_dbus_method_info_sensor_flip_horizontally = {-1, "SensorFlipHorizontally", (GDBusArgInfo **) (&_ipiped_mt9p031_dbus_arg_info_sensor_flip_horizontally_in), (GDBusArgInfo **) (&_ipiped_mt9p031_dbus_arg_info_sensor_flip_horizontally_out)};
static const GDBusArgInfo _ipiped_mt9p031_dbus_arg_info_set_exposure_time__exp_time = {-1, "_exp_time", "i"};
static const GDBusArgInfo _ipiped_mt9p031_dbus_arg_info_set_exposure_time_result = {-1, "result", "i"};
static const GDBusArgInfo * const _ipiped_mt9p031_dbus_arg_info_set_exposure_time_in[] = {&_ipiped_mt9p031_dbus_arg_info_set_exposure_time__exp_time, NULL};
static const GDBusArgInfo * const _ipiped_mt9p031_dbus_arg_info_set_exposure_time_out[] = {&_ipiped_mt9p031_dbus_arg_info_set_exposure_time_result, NULL};
static const GDBusMethodInfo _ipiped_mt9p031_dbus_method_info_set_exposure_time = {-1, "SetExposureTime", (GDBusArgInfo **) (&_ipiped_mt9p031_dbus_arg_info_set_exposure_time_in), (GDBusArgInfo **) (&_ipiped_mt9p031_dbus_arg_info_set_exposure_time_out)};
static const GDBusArgInfo _ipiped_mt9p031_dbus_arg_info_get_exposure_time_result = {-1, "result", "i"};
static const GDBusArgInfo * const _ipiped_mt9p031_dbus_arg_info_get_exposure_time_in[] = {NULL};
static const GDBusArgInfo * const _ipiped_mt9p031_dbus_arg_info_get_exposure_time_out[] = {&_ipiped_mt9p031_dbus_arg_info_get_exposure_time_result, NULL};
static const GDBusMethodInfo _ipiped_mt9p031_dbus_method_info_get_exposure_time = {-1, "GetExposureTime", (GDBusArgInfo **) (&_ipiped_mt9p031_dbus_arg_info_get_exposure_time_in), (GDBusArgInfo **) (&_ipiped_mt9p031_dbus_arg_info_get_exposure_time_out)};
static const GDBusMethodInfo * const _ipiped_mt9p031_dbus_method_info[] = {&_ipiped_mt9p031_dbus_method_info_set_sensor_gain, &_ipiped_mt9p031_dbus_method_info_get_sensor_gain, &_ipiped_mt9p031_dbus_method_info_sensor_flip_vertically, &_ipiped_mt9p031_dbus_method_info_sensor_flip_horizontally, &_ipiped_mt9p031_dbus_method_info_set_exposure_time, &_ipiped_mt9p031_dbus_method_info_get_exposure_time, NULL};
static const GDBusSignalInfo * const _ipiped_mt9p031_dbus_signal_info[] = {NULL};
static const GDBusPropertyInfo * const _ipiped_mt9p031_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _ipiped_mt9p031_dbus_interface_info = {-1, "com.ridgerun.mt9p031Interface", (GDBusMethodInfo **) (&_ipiped_mt9p031_dbus_method_info), (GDBusSignalInfo **) (&_ipiped_mt9p031_dbus_signal_info), (GDBusPropertyInfo **) (&_ipiped_mt9p031_dbus_property_info)};
static const GDBusInterfaceVTable _ipiped_mt9p031_dbus_interface_vtable = {ipiped_mt9p031_dbus_interface_method_call, ipiped_mt9p031_dbus_interface_get_property, ipiped_mt9p031_dbus_interface_set_property};

/**
     * Create a new instance of a Ipipe daemon
     */
Ipiped_mt9p031* ipiped_mt9p031_construct (GType object_type) {
	Ipiped_mt9p031 * self = NULL;
	self = (Ipiped_mt9p031*) abstc_sensor_construct (object_type);
	abstc_sensor_debug = FALSE;
	((AbstcSensor*) self)->capture_fd = -1;
	((AbstcSensor*) self)->owner_capture_fd = (gchar) 1;
	return self;
}


Ipiped_mt9p031* ipiped_mt9p031_new (void) {
	return ipiped_mt9p031_construct (TYPE_IPIPED_MT9P031);
}


/**
     * Open sensor
     * Open the video capture device, obtain the correspondly file 
     * descriptor */
static gint ipiped_mt9p031_open_sensor (Ipiped_mt9p031* self) {
	gint result = 0;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = open ("/dev/video0", O_RDWR | O_NONBLOCK, (mode_t) 0);
	((AbstcSensor*) self)->capture_fd = _tmp0_;
	g_assert (((AbstcSensor*) self)->capture_fd >= 0);
	((AbstcSensor*) self)->owner_capture_fd = (gchar) 0;
	result = 0;
	return result;
}


/**
    * Sets sensor gain for each color R, Gr, Gb, B (mt9p031)
    * Each gain component can range from 1 to 128 in steps of:
    *      0.125 if gain between 1 and 4
    *      0.250 if gain between 4.25 and 8
    *      1.000 if gain betwewn 8 and 128
    * @param fd structure with file descriptors and owner flags
    * @param r_gain red gain [1, 128]
    * @param g_gain green gain [1, 128]
    * @param b_gain blue gain [1, 128]
    */
static gint ipiped_mt9p031_set_sensor_gain_i (Ipiped_mt9p031* self, gint* capture_fd, gchar* owner_capture_fd, guint32 q10r_gain, guint32 q10g_gain, guint32 q10b_gain) {
	gint result = 0;
	struct v4l2_control ctrl = {0};
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	memset (&ctrl, 0, sizeof (struct v4l2_control));
	if (((AbstcSensor*) self)->capture_fd < 0) {
		ipiped_mt9p031_open_sensor (self);
	}
	ctrl.id = (guint32) V4L2_CID_RED_BALANCE;
	ctrl.value = (gint32) ((gint) (q10r_gain >> 7));
	_tmp0_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_S_CTRL, &ctrl);
	if ((-1) == _tmp0_) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "ioctl:VIDIOC_S_CTRL failed:red\n");
		}
		result = -1;
		return result;
	}
	ctrl.id = (guint32) V4L2_CID_BRIGHTNESS;
	ctrl.value = (gint32) ((gint) (q10g_gain >> 7));
	_tmp1_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_S_CTRL, &ctrl);
	if ((-1) == _tmp1_) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "ioctl:VIDIOC_S_CTRL failed:green1\n");
		}
		result = -1;
		return result;
	}
	ctrl.id = (guint32) V4L2_CID_AUTOGAIN;
	_tmp2_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_S_CTRL, &ctrl);
	if ((-1) == _tmp2_) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "ioctl:VIDIOC_S_CTRL failed:green2\n");
		}
		result = -1;
		return result;
	}
	ctrl.id = (guint32) V4L2_CID_BLUE_BALANCE;
	ctrl.value = (gint32) ((gint) (q10b_gain >> 7));
	_tmp3_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_S_CTRL, &ctrl);
	if ((-1) == _tmp3_) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "ioctl:VIDIOC_S_CTRL failed:blue\n");
		}
		result = -1;
		return result;
	}
	if (abstc_sensor_debug) {
		fprintf (stdout, "Set gain in the sensor  r=%f, g=%f ,b=%f\n", (gdouble) (((gfloat) q10r_gain) / 1024), (gdouble) (((gfloat) q10g_gain) / 1024), (gdouble) (((gfloat) q10b_gain) / 1024));
	}
	result = 0;
	return result;
}


/** 
     * Set sensor gain
     * Cast the float RGB gains to fixed-point q3 and use the 
     * set_sensor_gain_st function to ajust the sensor gains
     */
gint ipiped_mt9p031_set_sensor_gain (Ipiped_mt9p031* self, gdouble r_gain, gdouble g_gain, gdouble b_gain, GError** error) {
	gint result = 0;
	guint32 q10r_gain;
	guint32 q10g_gain;
	guint32 q10b_gain;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	if (((AbstcSensor*) self)->capture_fd < 0) {
		ipiped_mt9p031_open_sensor (self);
	}
	q10r_gain = (guint32) ((r_gain + (0.125 / 2)) * 1024);
	q10g_gain = (guint32) ((g_gain + (0.125 / 2)) * 1024);
	q10b_gain = (guint32) ((b_gain + (0.125 / 2)) * 1024);
	_tmp0_ = ipiped_mt9p031_set_sensor_gain_i (self, &((AbstcSensor*) self)->capture_fd, &((AbstcSensor*) self)->owner_capture_fd, q10r_gain, q10g_gain, q10b_gain);
	result = _tmp0_;
	return result;
}


/**
     * Get the combined gain of each color in the sensor registers. 
     * Each gain component can range from 1 to 128 in steps of:
     *      0.125 if gain between 1 and 4
     *      0.250 if gain between 4.25 and 8
     *      1.000 if gain betwewn 8 and 128
     * @param fd structure with file descriptors and owner flags
     * @param r_gain pointer to get the red gain
     * @param g_gain pointer to get the green gain
     * @param b_gain pointer to get the blue gain
     */
static gint ipiped_mt9p031_get_sensor_gain_i (Ipiped_mt9p031* self, gint* capture_fd, gchar* owner_capture_fd, guint32* q10r_gain, guint32* q10g_gain, guint32* q10b_gain) {
	gint result = 0;
	struct v4l2_control ctrl = {0};
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	g_return_val_if_fail (self != NULL, 0);
	memset (&ctrl, 0, sizeof (struct v4l2_control));
	if (((AbstcSensor*) self)->capture_fd < 0) {
		fprintf (stderr, "Fail get sensor gain\n");
		result = -1;
		return result;
	}
	ctrl.id = (guint32) V4L2_CID_RED_BALANCE;
	_tmp0_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_G_CTRL, &ctrl);
	if ((-1) == _tmp0_) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "ioctl:VIDIOC_G_CTRL failed: get red balance\n");
		}
		result = -1;
		return result;
	}
	*q10r_gain = (guint32) (ctrl.value << 7);
	ctrl.id = (guint32) V4L2_CID_BLUE_BALANCE;
	_tmp1_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_G_CTRL, &ctrl);
	if ((-1) == _tmp1_) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "ioctl:VIDIOC_G_CTRL failed: get red balance\n");
		}
		result = -1;
		return result;
	}
	*q10b_gain = (guint32) (ctrl.value << 7);
	ctrl.id = (guint32) V4L2_CID_BRIGHTNESS;
	_tmp2_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_G_CTRL, &ctrl);
	if ((-1) == _tmp2_) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "ioctl:VIDIOC_G_CTRL failed: get red balance\n");
		}
		result = -1;
		return result;
	}
	*q10g_gain = (guint32) (ctrl.value << 7);
	result = 0;
	return result;
}


/** 
     * Get sensor gain
     * Use the get_sensor_gain_i function to obtain the RGB sensor gains 
     * and print them
     */
gint ipiped_mt9p031_get_sensor_gain (Ipiped_mt9p031* self, GError** error) {
	gint result = 0;
	guint32 q10red_gain;
	guint32 q10green_gain;
	guint32 q10blue_gain;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	q10red_gain = (guint32) 0;
	q10green_gain = (guint32) 0;
	q10blue_gain = (guint32) 0;
	if (((AbstcSensor*) self)->capture_fd < 0) {
		ipiped_mt9p031_open_sensor (self);
	}
	_tmp0_ = ipiped_mt9p031_get_sensor_gain_i (self, &((AbstcSensor*) self)->capture_fd, &((AbstcSensor*) self)->owner_capture_fd, &q10red_gain, &q10green_gain, &q10blue_gain);
	if (_tmp0_ < 0) {
		result = -1;
		return result;
	}
	fprintf (stdout, "Set gain to R=%f  G=%f  B=%f\n", (gdouble) (((gfloat) q10red_gain) / 1024), (gdouble) (((gfloat) q10green_gain) / 1024), (gdouble) (((gfloat) q10blue_gain) / 1024));
	result = 0;
	return result;
}


/**
     * Flip the image vetically 
     * Change the state of the vertical flip flag to reverse the image's 
     * rows. When mirroring the rows, the bayer pattern is preserved for 
     * the pixel order, that means the bayer pattern readout is reversed as the pixels.
     * @param state is an on/off flag. If the value is 1 image's columns 
     * must be reversed, if 0 they must not
     */
gint ipiped_mt9p031_sensor_flip_vertically (Ipiped_mt9p031* self, const gchar* state, GError** error) {
	gint result = 0;
	struct v4l2_control ctrl = {0};
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (state != NULL, 0);
	memset (&ctrl, 0, sizeof (struct v4l2_control));
	if (((AbstcSensor*) self)->capture_fd < 0) {
		ipiped_mt9p031_open_sensor (self);
	}
	if (g_strcmp0 (state, "ON") == 0) {
		ctrl.value = (gint32) 1;
	} else {
		if (g_strcmp0 (state, "OFF") == 0) {
			ctrl.value = (gint32) 0;
		} else {
			if (abstc_sensor_debug) {
				fprintf (stderr, "Ipiped: Invalid vertical flip state\n");
			}
			result = -1;
			return result;
		}
	}
	ctrl.id = (guint32) V4L2_CID_VFLIP;
	_tmp0_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_S_CTRL, &ctrl);
	if ((-1) == _tmp0_) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "%s", "ioctl:VIDIOC_S_CTRL failed:" "vertical flip\n");
		}
		result = -1;
		return result;
	}
	result = 0;
	return result;
}


/**
     * Flip the image horizontally 
     * Change the state of the horizontal flip flag to reverse the image's 
     * columns. When mirroring the columns, the bayer pattern is preserved 
     * for the pixel order, that means the bayer pattern readout is reversed 
     * as the pixels.
     * @param state is an on/off flag. If the value is 1 image's columns 
     * must be reversed, if 0 they must not
     */
gint ipiped_mt9p031_sensor_flip_horizontally (Ipiped_mt9p031* self, const gchar* state, GError** error) {
	gint result = 0;
	struct v4l2_control ctrl = {0};
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (state != NULL, 0);
	memset (&ctrl, 0, sizeof (struct v4l2_control));
	if (((AbstcSensor*) self)->capture_fd < 0) {
		ipiped_mt9p031_open_sensor (self);
	}
	if (g_strcmp0 (state, "ON") == 0) {
		ctrl.value = (gint32) 1;
	} else {
		if (g_strcmp0 (state, "OFF") == 0) {
			ctrl.value = (gint32) 0;
		} else {
			if (abstc_sensor_debug) {
				fprintf (stderr, "Ipiped: Invalid horizontal flip state\n");
			}
			result = -1;
			return result;
		}
	}
	ctrl.id = (guint32) V4L2_CID_HFLIP;
	_tmp0_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_S_CTRL, &ctrl);
	if ((-1) == _tmp0_) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "%s", "ioctl:VIDIOC_S_CTRL failed: " "horizontal flip\n");
		}
		result = -1;
		return result;
	}
	result = 0;
	return result;
}


/**
     * Sets exposure time 
     * Sets the effective shutter time that is the integration time for 
     * the light in the CMOS sensor receptors
     * @param fd structure with file descriptors and owner flags
     * @param exp_time exposure time in us
     */
static gint ipiped_mt9p031_set_exposure_time_i (Ipiped_mt9p031* self, gint* capture_fd, gchar* owner_capture_fd, guint32 exp_time) {
	gint result = 0;
	struct v4l2_control ctrl = {0};
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	memset (&ctrl, 0, sizeof (struct v4l2_control));
	ctrl.id = (guint32) V4L2_CID_EXPOSURE;
	ctrl.value = ((gint32) exp_time) << 8;
	_tmp0_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_S_CTRL, &ctrl);
	if ((-1) == _tmp0_) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "ioctl:VIDIOC_S_CTRL failed: set exposure time\n");
		}
		result = -1;
		return result;
	}
	if (abstc_sensor_debug) {
		fprintf (stdout, "Set exposure time to: %u\n", (guint) exp_time);
	}
	result = 0;
	return result;
}


gint ipiped_mt9p031_set_exposure_time (Ipiped_mt9p031* self, gint _exp_time, GError** error) {
	gint result = 0;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	if (((AbstcSensor*) self)->capture_fd < 0) {
		ipiped_mt9p031_open_sensor (self);
	}
	_tmp0_ = ipiped_mt9p031_set_exposure_time_i (self, &((AbstcSensor*) self)->capture_fd, &((AbstcSensor*) self)->owner_capture_fd, (guint32) _exp_time);
	result = _tmp0_;
	return result;
}


/**
     * Get exposure time
     * Obtain from the sensor the actual ligth integration time
     * @param fd structure with file descriptors and owner flags
     * @param exp_time pointer where the function leave the exposure time in us  
     */
static gint ipiped_mt9p031_get_exposure_time_i (Ipiped_mt9p031* self, gint* capture_fd, gchar* owner_capture_fd, guint32* exp) {
	gint result = 0;
	struct v4l2_control ctrl = {0};
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	memset (&ctrl, 0, sizeof (struct v4l2_control));
	ctrl.id = (guint32) V4L2_CID_EXPOSURE;
	_tmp0_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_G_CTRL, &ctrl);
	if ((-1) == _tmp0_) {
		if (abstc_sensor_debug == TRUE) {
			fprintf (stderr, "%s", "ioctl:VIDIOC_G_CTRL failed: get exposure" " time\n");
		}
		result = -1;
		return result;
	}
	*exp = (guint32) (ctrl.value >> 8);
	result = 0;
	return result;
}


gint ipiped_mt9p031_get_exposure_time (Ipiped_mt9p031* self, GError** error) {
	gint result = 0;
	guint32 exp_time;
	g_return_val_if_fail (self != NULL, 0);
	exp_time = (guint32) 0;
	if (((AbstcSensor*) self)->capture_fd < 0) {
		ipiped_mt9p031_open_sensor (self);
	}
	ipiped_mt9p031_get_exposure_time_i (self, &((AbstcSensor*) self)->capture_fd, &((AbstcSensor*) self)->owner_capture_fd, &exp_time);
	fprintf (stdout, "Exposure time: %u\n", (guint) exp_time);
	result = 0;
	return result;
}


/**
     * Get the frame vertical orientation (mt9p031)
     * @param vf is an on/off flag. If the value is 1 image's rows are 
     * reversed, if 0 they are not
     */
static gint ipiped_mt9p031_get_vertical_flip (Ipiped_mt9p031* self, gint* vf) {
	gint result = 0;
	struct v4l2_control ctrl = {0};
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	memset (&ctrl, 0, sizeof (struct v4l2_control));
	if (((AbstcSensor*) self)->capture_fd < 0) {
		ipiped_mt9p031_open_sensor (self);
	}
	ctrl.id = (guint32) V4L2_CID_VFLIP;
	_tmp0_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_G_CTRL, &ctrl);
	if ((-1) == _tmp0_) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "ioctl:VIDIOC_G_CTRL failed: get vertical flip\n");
		}
		result = -1;
		return result;
	}
	*vf = (gint) ctrl.value;
	result = 0;
	return result;
}


/**
     * Get the frame horizontal orientation (mt9p031)
     * @param hf is an on/off flag. If the value is 1 image's columns are 
     * reversed, if 0 they are not
     */
static gint ipiped_mt9p031_get_horizontal_flip (Ipiped_mt9p031* self, gint* hf) {
	gint result = 0;
	struct v4l2_control ctrl = {0};
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	memset (&ctrl, 0, sizeof (struct v4l2_control));
	if (((AbstcSensor*) self)->capture_fd < 0) {
		ipiped_mt9p031_open_sensor (self);
	}
	ctrl.id = (guint32) V4L2_CID_HFLIP;
	_tmp0_ = ioctl (((AbstcSensor*) self)->capture_fd, VIDIOC_G_CTRL, &ctrl);
	if ((-1) == _tmp0_) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "ioctl:VIDIOC_G_CTRL failed: get vertical flip\n");
		}
		result = -1;
		return result;
	}
	*hf = (gint) ctrl.value;
	result = 0;
	return result;
}


/**
     * Get the pixel position for each color pattern
     * @param color_pattern, array that contains the pixel position
     *                       of R, Gr, Gb and B 
     */
static gboolean ipiped_mt9p031_get_color_pattern (Ipiped_mt9p031* self, struct colorpattern* color_pattern) {
	gboolean result = FALSE;
	gint vf;
	gint hf;
	gint ret;
	gint _tmp0_;
	gint _tmp1_;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	vf = 0;
	hf = 0;
	ret = 0;
	_tmp0_ = ipiped_mt9p031_get_vertical_flip (self, &vf);
	ret = _tmp0_;
	_tmp1_ = ipiped_mt9p031_get_horizontal_flip (self, &hf);
	ret = ret + _tmp1_;
	if (ret != 0) {
		if (abstc_sensor_debug) {
			fprintf (stderr, "Error:\n Failed to get frame orientation\n");
		}
		result = FALSE;
		return result;
	}
	if (vf == 1) {
		_tmp2_ = hf == 1;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		*color_pattern = colorptn_GbBRGr;
	} else {
		gboolean _tmp3_ = FALSE;
		if (vf == 0) {
			_tmp3_ = hf == 1;
		} else {
			_tmp3_ = FALSE;
		}
		if (_tmp3_) {
			*color_pattern = colorptn_RGrGbB;
		} else {
			gboolean _tmp4_ = FALSE;
			if (vf == 1) {
				_tmp4_ = hf == 0;
			} else {
				_tmp4_ = FALSE;
			}
			if (_tmp4_) {
				*color_pattern = colorptn_BGbGrR;
			} else {
				*color_pattern = colorptn_GrRBGb;
			}
		}
	}
	result = TRUE;
	return result;
}


static gint _ipiped_mt9p031_set_sensor_gain_i_set_gain (gint* fd, gchar* owner_fd, guint32 r_gain, guint32 g_gain, guint32 b_gain, gpointer self) {
	gint result;
	result = ipiped_mt9p031_set_sensor_gain_i (self, fd, owner_fd, r_gain, g_gain, b_gain);
	return result;
}


static gint _ipiped_mt9p031_get_sensor_gain_i_get_gain (gint* fd, gchar* owner_fd, guint32* r_gain, guint32* g_gain, guint32* b_gain, gpointer self) {
	gint result;
	result = ipiped_mt9p031_get_sensor_gain_i (self, fd, owner_fd, r_gain, g_gain, b_gain);
	return result;
}


static gint _ipiped_mt9p031_set_exposure_time_i_set_exposure (gint* capture_fd, gchar* owner_capture_fd, guint32 exp_time, gpointer self) {
	gint result;
	result = ipiped_mt9p031_set_exposure_time_i (self, capture_fd, owner_capture_fd, exp_time);
	return result;
}


static gint _ipiped_mt9p031_get_exposure_time_i_get_exposure (gint* capture_fd, gchar* owner_capture_fd, guint32* exp_time, gpointer self) {
	gint result;
	result = ipiped_mt9p031_get_exposure_time_i (self, capture_fd, owner_capture_fd, exp_time);
	return result;
}


static gint ipiped_mt9p031_real_get_sensor_data (AbstcSensor* base, struct rraew_sensor* sensor) {
	Ipiped_mt9p031 * self;
	gint result = 0;
	struct colorpattern colorptn = {0};
	gboolean _tmp0_;
	void* _tmp1_ = NULL;
	SetGain _tmp2_;
	GetGain _tmp3_;
	SetExposure _tmp4_;
	GetExposure _tmp5_;
	self = (Ipiped_mt9p031*) base;
	memset (&colorptn, 0, sizeof (struct colorpattern));
	_tmp0_ = ipiped_mt9p031_get_color_pattern (self, &colorptn);
	if (!_tmp0_) {
		fprintf (stderr, "Error:\n Failed to get color pattern\n");
		result = -1;
		return result;
	}
	(*sensor).colorptn = colorptn;
	(*sensor).max_exp_time = 2500;
	(*sensor).min_exp_time = 1;
	(*sensor).max_gain = (gfloat) 128;
	(*sensor).min_gain = (gfloat) 1;
	(*sensor).n_gain_steps = 3;
	_tmp1_ = g_malloc ((gsize) ((*sensor).n_gain_steps * sizeof (struct rraew_gain_step)));
	(*sensor).gain_steps = (struct rraew_gain_step*) _tmp1_;
	(*sensor).gain_steps[0].range_end = (gfloat) 4;
	(*sensor).gain_steps[0].step_n = 1;
	(*sensor).gain_steps[0].step_d = 8;
	(*sensor).gain_steps[1].range_end = (gfloat) 8;
	(*sensor).gain_steps[1].step_n = 1;
	(*sensor).gain_steps[1].step_d = 4;
	(*sensor).gain_steps[2].range_end = (gfloat) 128;
	(*sensor).gain_steps[2].step_n = 1;
	(*sensor).gain_steps[2].step_d = 1;
	_tmp2_ = _ipiped_mt9p031_set_sensor_gain_i_set_gain;
	(*sensor).set_gain_target = self;
	(*sensor).set_gain = _tmp2_;
	_tmp3_ = _ipiped_mt9p031_get_sensor_gain_i_get_gain;
	(*sensor).get_gain_target = self;
	(*sensor).get_gain = _tmp3_;
	_tmp4_ = _ipiped_mt9p031_set_exposure_time_i_set_exposure;
	(*sensor).set_exposure_target = self;
	(*sensor).set_exposure = _tmp4_;
	_tmp5_ = _ipiped_mt9p031_get_exposure_time_i_get_exposure;
	(*sensor).get_exposure_target = self;
	(*sensor).get_exposure = _tmp5_;
	result = 0;
	return result;
}


static void ipiped_mt9p031_class_init (Ipiped_mt9p031Class * klass) {
	ipiped_mt9p031_parent_class = g_type_class_peek_parent (klass);
	ABSTC_SENSOR_CLASS (klass)->get_sensor_data = ipiped_mt9p031_real_get_sensor_data;
}


static void ipiped_mt9p031_instance_init (Ipiped_mt9p031 * self) {
}


GType ipiped_mt9p031_get_type (void) {
	static volatile gsize ipiped_mt9p031_type_id__volatile = 0;
	if (g_once_init_enter (&ipiped_mt9p031_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (Ipiped_mt9p031Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ipiped_mt9p031_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Ipiped_mt9p031), 0, (GInstanceInitFunc) ipiped_mt9p031_instance_init, NULL };
		GType ipiped_mt9p031_type_id;
		ipiped_mt9p031_type_id = g_type_register_static (TYPE_ABSTC_SENSOR, "Ipiped_mt9p031", &g_define_type_info, 0);
		g_type_set_qdata (ipiped_mt9p031_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) ipiped_mt9p031_register_object);
		g_once_init_leave (&ipiped_mt9p031_type_id__volatile, ipiped_mt9p031_type_id);
	}
	return ipiped_mt9p031_type_id__volatile;
}


static void _dbus_ipiped_mt9p031_set_sensor_gain (Ipiped_mt9p031* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gdouble r_gain = 0.0;
	GVariant* _tmp18_;
	gdouble g_gain = 0.0;
	GVariant* _tmp19_;
	gdouble b_gain = 0.0;
	GVariant* _tmp20_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gint result;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp18_ = g_variant_iter_next_value (&_arguments_iter);
	r_gain = g_variant_get_double (_tmp18_);
	g_variant_unref (_tmp18_);
	_tmp19_ = g_variant_iter_next_value (&_arguments_iter);
	g_gain = g_variant_get_double (_tmp19_);
	g_variant_unref (_tmp19_);
	_tmp20_ = g_variant_iter_next_value (&_arguments_iter);
	b_gain = g_variant_get_double (_tmp20_);
	g_variant_unref (_tmp20_);
	result = ipiped_mt9p031_set_sensor_gain (self, r_gain, g_gain, b_gain, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_int32 (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipiped_mt9p031_get_sensor_gain (Ipiped_mt9p031* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gint result;
	g_variant_iter_init (&_arguments_iter, parameters);
	result = ipiped_mt9p031_get_sensor_gain (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_int32 (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipiped_mt9p031_sensor_flip_vertically (Ipiped_mt9p031* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* state = NULL;
	GVariant* _tmp21_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gint result;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp21_ = g_variant_iter_next_value (&_arguments_iter);
	state = g_variant_dup_string (_tmp21_, NULL);
	g_variant_unref (_tmp21_);
	result = ipiped_mt9p031_sensor_flip_vertically (self, state, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_int32 (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (state);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipiped_mt9p031_sensor_flip_horizontally (Ipiped_mt9p031* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* state = NULL;
	GVariant* _tmp22_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gint result;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp22_ = g_variant_iter_next_value (&_arguments_iter);
	state = g_variant_dup_string (_tmp22_, NULL);
	g_variant_unref (_tmp22_);
	result = ipiped_mt9p031_sensor_flip_horizontally (self, state, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_int32 (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (state);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipiped_mt9p031_set_exposure_time (Ipiped_mt9p031* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gint _exp_time = 0;
	GVariant* _tmp23_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gint result;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp23_ = g_variant_iter_next_value (&_arguments_iter);
	_exp_time = g_variant_get_int32 (_tmp23_);
	g_variant_unref (_tmp23_);
	result = ipiped_mt9p031_set_exposure_time (self, _exp_time, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_int32 (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_ipiped_mt9p031_get_exposure_time (Ipiped_mt9p031* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gint result;
	g_variant_iter_init (&_arguments_iter, parameters);
	result = ipiped_mt9p031_get_exposure_time (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_int32 (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void ipiped_mt9p031_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "SetSensorGain") == 0) {
		_dbus_ipiped_mt9p031_set_sensor_gain (object, parameters, invocation);
	} else if (strcmp (method_name, "GetSensorGain") == 0) {
		_dbus_ipiped_mt9p031_get_sensor_gain (object, parameters, invocation);
	} else if (strcmp (method_name, "SensorFlipVertically") == 0) {
		_dbus_ipiped_mt9p031_sensor_flip_vertically (object, parameters, invocation);
	} else if (strcmp (method_name, "SensorFlipHorizontally") == 0) {
		_dbus_ipiped_mt9p031_sensor_flip_horizontally (object, parameters, invocation);
	} else if (strcmp (method_name, "SetExposureTime") == 0) {
		_dbus_ipiped_mt9p031_set_exposure_time (object, parameters, invocation);
	} else if (strcmp (method_name, "GetExposureTime") == 0) {
		_dbus_ipiped_mt9p031_get_exposure_time (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* ipiped_mt9p031_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean ipiped_mt9p031_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


guint ipiped_mt9p031_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_ipiped_mt9p031_dbus_interface_info), &_ipiped_mt9p031_dbus_interface_vtable, data, _ipiped_mt9p031_unregister_object, error);
	if (!result) {
		return 0;
	}
	return result;
}


static void _ipiped_mt9p031_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}



